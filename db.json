{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/learn-git-in-developement.md","hash":"fad56dcbab5091bb0c4086d61c219b2e8b0182c5","modified":1644907732152},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1644906867897},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1644906867892},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1644906867892},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1644906867892},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1644906867893},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1644906867892},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1644906867895},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1644906867893},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1644906867893},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1644906867895},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1644906867895},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1644906867895},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1644906867896},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1644906867897},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1644906867896},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1644906867896},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1644906867897},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1644906867896},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1644906867897},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1644906867897},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1644906867894},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1644906867897},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1644906867898},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1644906867894},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1644906867898},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1644906867898},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1644906867898},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1644906867898},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1644906867899},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1644906867899},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1644906867899},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1644906867900},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1644906867901},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1644906867901},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1644906867899},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1644906867901},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1644906867901},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1644906867901},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1644906867904},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1644906867904},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1644906867905},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1644906867905},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1644906867904},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1644906867905},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1644906867905},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1644906867904},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1644906867902},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1644906867904},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1644906867904},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1644906867906},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1644906867906},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1644906867902},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1644906867902},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1644906867902},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1644906867902},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1644906867903},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1644906867903},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1644906867911},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1644906867904},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1644906867911},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1644906867906},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1644906867912},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1644906867911},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1644906867910},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1644906867908},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1644906867907},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1644906867907},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1644906867908},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1644906867909},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1644906867908},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1644906867908},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1644906867908},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1644906867909},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1644906867909},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1644906867906},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1644906867907},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1644906867911},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1644906867910},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1644906867910},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1644906867912},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1644906867909},{"_id":"public/2022/02/15/learn-git-in-developement/index.html","hash":"14631d7652f4b69bff792f02b8552bd289ce1144","modified":1750523997715},{"_id":"public/2022/02/15/hello-world/index.html","hash":"7d4e7fc28ff50a50ca682a559551da5d8e0796d0","modified":1750523997715},{"_id":"public/index.html","hash":"2faadc08e9a480826c96b0e5d5e4c7c4f0285712","modified":1750523997715},{"_id":"public/archives/index.html","hash":"3bc835918a2a39d58e595ac658fd9c12f7e9c46d","modified":1750523997715},{"_id":"public/archives/2022/index.html","hash":"d1908d3d575e19ea29d49bd427f6c69799189166","modified":1750523997715},{"_id":"public/archives/2022/02/index.html","hash":"da17c7c70dd20d5a8f0158bd0bad0c9d0804a431","modified":1750523997715},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1750523670743},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1750523670743},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1750523670743},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1750523670743},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1750523670743},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1750523670743},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1750523670743},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1750523670743},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1750523670743},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1750523670743},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1750523670743},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1750523670743},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1750523670743},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1750523670743},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1750523670743},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1750523670743},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1750523670743},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1750523670743},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1750523670743},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1750523670743},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1750523670743},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1750523670743},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1750523670743},{"_id":"source/_posts/test.md","hash":"66092bd5a60fbe52025b48f3380ad685f94ed6c5","modified":1750523792941},{"_id":"public/2025/06/22/test/index.html","hash":"905c97996d049e34a88cbaa5c8241cc7e8f1f2b7","modified":1750523997715},{"_id":"public/archives/2025/index.html","hash":"97ac3a72abc82022ed0e029e1713ea82971e324b","modified":1750523997715},{"_id":"public/archives/2025/06/index.html","hash":"eb22ebd90eff897dbf49c8b4d946da2fdf0c3a11","modified":1750523997715},{"_id":"source/_posts/测试.md","hash":"1851fee378322a996f702f5a14cb9f98e5df0d16","modified":1750523986558},{"_id":"public/2025/06/22/测试/index.html","hash":"81c383997b0ac3cebb210593321975f949b4d1bf","modified":1750523997715},{"_id":"source/_posts/git.md","hash":"8863f35072c11fc292bb8ccc5b3a0777978c3f47","modified":1750556395183},{"_id":"source/_posts/graphql看懂这篇直接开发.md","hash":"f13772a9b40eb22a37b7280063f81312806c48b7","modified":1750556395184},{"_id":"source/_posts/检测后端接口常见方法.md","hash":"ebf4157039164a38ff35163948b0b05affcca527","modified":1750556395186},{"_id":"source/_posts/react前端下载后端返回的文件方法（url、二进制流）.md","hash":"7a040873d9deccfbdb23e516ceceae03bda11f15","modified":1750556395185},{"_id":"source/_posts/每天一个新问题（永远保持怀疑）.md","hash":"1766635d2271b5bc31a4fc42901a1390d881a546","modified":1750556395187},{"_id":"source/_posts/浏览器安全.md","hash":"9ee43ca6fe462c22eaf2d0f1f66028513196eea6","modified":1750556395198},{"_id":"source/_posts/git/gitrebase.png","hash":"e3ac521c51beec9a85729e143d2a631e0ac55cba","modified":1750556395183},{"_id":"source/_posts/浏览器安全/非对称加密.png","hash":"726f42224e3b820bfbe4b47ebafebeb19167c2c6","modified":1750556395197},{"_id":"source/_posts/浏览器安全/浏览器安全.png","hash":"aaa65f1b424822e96a61f3c10dd77c0aae002e57","modified":1750556395195},{"_id":"source/_posts/浏览器安全/渲染进程与浏览器内核.png","hash":"cb854a85ad39a93b2baaeae65eaa4bcc75b5fa17","modified":1750556395196},{"_id":"source/_posts/浏览器安全/对称加密.png","hash":"7577ee47393c6c5b4819b4df501846f09490d33d","modified":1750556395191},{"_id":"source/_posts/浏览器安全/数字证书.png","hash":"a2c25869488db97bf2a1b5af4a880750d084b9de","modified":1750556395194},{"_id":"source/_posts/浏览器安全/对称混合非对称加密.png","hash":"7a69595fc45ec1f465ab334ee943d6fdc9678741","modified":1750556395192},{"_id":"source/_posts/浏览器安全/安全沙箱.png","hash":"839a7becbfe936c8b2a7ab1671f4db10b90dc23c","modified":1750556395189}],"Category":[{"name":"git","_id":"cmc703iqn0002wvtkdcjga9kd"},{"name":"后端接口","_id":"cmc703iqr0007wvtkbl5th6is"},{"name":"下载","_id":"cmc703iqt000cwvtk75a39sp0"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-15T06:34:27.897Z","updated":"2022-02-15T06:34:27.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznro0kj0000wufy295hcmiz","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"实战中开发git","date":"2022-05-22T13:34:00.000Z","comments":1,"_content":"# 初始化仓库\n\ngit init\n\n## 克隆仓库\n\ngit clone git地址\n\n## 设置用户名和邮箱(--global 为全局参数，表明本地所有Git仓库都会使用这个配置)\n\ngit config --global user,name \"用户名\"\ngit config --global user.email \"用户邮箱\"\n\n## 链接远程仓库\n\ngit remote add origin git地址\n\n### 当修改密码后需要git push 时报http denied错误时\n输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）\n或\ngit config --global http.emptyAuth true \n### 当本地查看远程分支时\n###     ** git fetch origin。拉取远程分支列表\n\n|git branch  |  |  |\n| --- | --- | --- |\n| | 空 |查看本地分支|\n|  |-r  | 查看远程分支 |\n|  | -a  | 查看全部焚毁  |\n\n# 撤销git add . 的方法 -> git restore .\n\n## 撤销git commit -m \"注释\"，\n\n| git reset | --hard | 删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。 |\n| --- | --- | --- |\n|  | --mixed | 不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset --mixed HEAD^==git reset HEAD^ |\n|  | --sort | 不删除工作空间改动代码，不撤销git add ，撤销commit|\n| git commit  | --amend | 如果commit注释写错了，改一下注释 |\n\n## 推送仓库\n\n| git push | -u | 建立+推送远程分支 |\n| --- | --- | --- |\n|  | -f | 强制覆盖远程分支 |\n\n### 暂时存储工作区代码，（可以在分支间横跳代码）\n\n| git stash save \"save message\" | 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。 |\n| --- | --- |\n| git stash list | 查看stash了哪些存储 |\n| git stash show | 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} |\n| git stash show -p | 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p |\n| git stash apply | 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} |\n| git stash pop | 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1} |\n| git stash drop stash@{$num} | 丢弃stash@{$num}存储，从列表中删除这个存储 |\n| git stash clear | 删除所有缓存的stash |\n\n# 创建分支\n\ngit branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。\ngit checkout -b test; 创建并切换到test分支\n\n# 删除分支\n\ngit branch -d test：删除本地test分支\n\ngit branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。\n\ngit push origin --delete test 删除远程test分支\n\ngit push origin :test 删除远程test分支\n\n# 查看分支\n\n|git  | branch |空  |列出当前分支清单  |\n| --- | --- | --- | --- |\n|  |  | -r | 查看远程分支 |\n|  |  |-a  | 查看远程分支和本地分支 |\n|  |  | -v |查看各个分支最后一个提交信息  |\n|  |  |--merged  | 查看哪些分支已经合并入当前分支 |\n\n\n# 拉取分支\n\ngit fetch origin 同步远程服务器的数据到本地\n\ngit checkout -b test origin/test\\_remote 将远程分支test\\_remote拉取下来到本地test分支\n\ngit checkout test 将远程分支test拉取下来到本地test分支\n\ngit pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test\n\n## git merge的参数\nmerge的两个分支要有历史关联，没有的话需要添加git merge master --allow-unrelated-histories，参数。\n\n|git  |  merge |  | 合并分支到当前分支 |\n| --- | --- | --- | --- |\n|  |  | --ff  | 快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决 |\n|  |  |--ff-only  | 只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge  |\n|  |  |--no-ff   | 不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景） |\n|  |  | --squash | 压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来 |\n\n## git rebase的参数\n\n| git | rebase | 分布湿合并分支 |\n| --- | --- | --- |\n|-i HEAD~num  | 合并后num个commit记录 | p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。 |\n|-i [start] [end]  | 左开右闭 | start和end分别代码commit id |\n|-i [start] [end]  | onto [newbase] | 将部分分支复制到新commit上，实现中间一大段commit的删除 |\n通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)\n\n![截屏2021-12-01 18.38.28.png](gitrebase.png)\n在用d时可删除部分分支。s时前面得有pick，\n本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)\n### 复制部分分支\n\ngit rebase \\[startpoint\\] \\[endpoint\\] \\-\\-onto \\[branchName\\] （\\[startpoint\\] \\[endpoint\\]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）\n运行git rebase --continue命令继续变基。\n运行git rebase --abort命令回到rebase之前的状态。\n个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。\n\n# git commit 记录查询\n\n|  git | show | 空 |.查看最新的commit|\n| --- | --- | --- | --- |\n|  |  | commitId  | .查看指定commit hashID的所有修改：|\n|  |  | commitId fileName |.查看某次commit中具体某个文件的修改： |","source":"_posts/git.md","raw":"---\ntitle: 实战中开发git\ndate: 2022-05-22 21:34:00\ntags: git javascript\ncategories: git\ncomments: true\n---\n# 初始化仓库\n\ngit init\n\n## 克隆仓库\n\ngit clone git地址\n\n## 设置用户名和邮箱(--global 为全局参数，表明本地所有Git仓库都会使用这个配置)\n\ngit config --global user,name \"用户名\"\ngit config --global user.email \"用户邮箱\"\n\n## 链接远程仓库\n\ngit remote add origin git地址\n\n### 当修改密码后需要git push 时报http denied错误时\n输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）\n或\ngit config --global http.emptyAuth true \n### 当本地查看远程分支时\n###     ** git fetch origin。拉取远程分支列表\n\n|git branch  |  |  |\n| --- | --- | --- |\n| | 空 |查看本地分支|\n|  |-r  | 查看远程分支 |\n|  | -a  | 查看全部焚毁  |\n\n# 撤销git add . 的方法 -> git restore .\n\n## 撤销git commit -m \"注释\"，\n\n| git reset | --hard | 删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。 |\n| --- | --- | --- |\n|  | --mixed | 不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset --mixed HEAD^==git reset HEAD^ |\n|  | --sort | 不删除工作空间改动代码，不撤销git add ，撤销commit|\n| git commit  | --amend | 如果commit注释写错了，改一下注释 |\n\n## 推送仓库\n\n| git push | -u | 建立+推送远程分支 |\n| --- | --- | --- |\n|  | -f | 强制覆盖远程分支 |\n\n### 暂时存储工作区代码，（可以在分支间横跳代码）\n\n| git stash save \"save message\" | 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。 |\n| --- | --- |\n| git stash list | 查看stash了哪些存储 |\n| git stash show | 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} |\n| git stash show -p | 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p |\n| git stash apply | 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} |\n| git stash pop | 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1} |\n| git stash drop stash@{$num} | 丢弃stash@{$num}存储，从列表中删除这个存储 |\n| git stash clear | 删除所有缓存的stash |\n\n# 创建分支\n\ngit branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。\ngit checkout -b test; 创建并切换到test分支\n\n# 删除分支\n\ngit branch -d test：删除本地test分支\n\ngit branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。\n\ngit push origin --delete test 删除远程test分支\n\ngit push origin :test 删除远程test分支\n\n# 查看分支\n\n|git  | branch |空  |列出当前分支清单  |\n| --- | --- | --- | --- |\n|  |  | -r | 查看远程分支 |\n|  |  |-a  | 查看远程分支和本地分支 |\n|  |  | -v |查看各个分支最后一个提交信息  |\n|  |  |--merged  | 查看哪些分支已经合并入当前分支 |\n\n\n# 拉取分支\n\ngit fetch origin 同步远程服务器的数据到本地\n\ngit checkout -b test origin/test\\_remote 将远程分支test\\_remote拉取下来到本地test分支\n\ngit checkout test 将远程分支test拉取下来到本地test分支\n\ngit pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test\n\n## git merge的参数\nmerge的两个分支要有历史关联，没有的话需要添加git merge master --allow-unrelated-histories，参数。\n\n|git  |  merge |  | 合并分支到当前分支 |\n| --- | --- | --- | --- |\n|  |  | --ff  | 快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决 |\n|  |  |--ff-only  | 只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge  |\n|  |  |--no-ff   | 不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景） |\n|  |  | --squash | 压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来 |\n\n## git rebase的参数\n\n| git | rebase | 分布湿合并分支 |\n| --- | --- | --- |\n|-i HEAD~num  | 合并后num个commit记录 | p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。 |\n|-i [start] [end]  | 左开右闭 | start和end分别代码commit id |\n|-i [start] [end]  | onto [newbase] | 将部分分支复制到新commit上，实现中间一大段commit的删除 |\n通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)\n\n![截屏2021-12-01 18.38.28.png](gitrebase.png)\n在用d时可删除部分分支。s时前面得有pick，\n本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)\n### 复制部分分支\n\ngit rebase \\[startpoint\\] \\[endpoint\\] \\-\\-onto \\[branchName\\] （\\[startpoint\\] \\[endpoint\\]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）\n运行git rebase --continue命令继续变基。\n运行git rebase --abort命令回到rebase之前的状态。\n个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。\n\n# git commit 记录查询\n\n|  git | show | 空 |.查看最新的commit|\n| --- | --- | --- | --- |\n|  |  | commitId  | .查看指定commit hashID的所有修改：|\n|  |  | commitId fileName |.查看某次commit中具体某个文件的修改： |","slug":"git","published":1,"updated":"2025-06-22T01:39:55.183Z","layout":"post","photos":[],"link":"","_id":"cmc703iqj0000wvtk5whbhk3u","content":"<h1 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h1><p>git init</p>\n<h2 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库\"></a>克隆仓库</h2><p>git clone git地址</p>\n<h2 id=\"设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\"><a href=\"#设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\" class=\"headerlink\" title=\"设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)\"></a>设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)</h2><p>git config –global user,name “用户名”<br>git config –global user.email “用户邮箱”</p>\n<h2 id=\"链接远程仓库\"><a href=\"#链接远程仓库\" class=\"headerlink\" title=\"链接远程仓库\"></a>链接远程仓库</h2><p>git remote add origin git地址</p>\n<h3 id=\"当修改密码后需要git-push-时报http-denied错误时\"><a href=\"#当修改密码后需要git-push-时报http-denied错误时\" class=\"headerlink\" title=\"当修改密码后需要git push 时报http denied错误时\"></a>当修改密码后需要git push 时报http denied错误时</h3><p>输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）<br>或<br>git config –global http.emptyAuth true </p>\n<h3 id=\"当本地查看远程分支时\"><a href=\"#当本地查看远程分支时\" class=\"headerlink\" title=\"当本地查看远程分支时\"></a>当本地查看远程分支时</h3><h3 id=\"git-fetch-origin。拉取远程分支列表\"><a href=\"#git-fetch-origin。拉取远程分支列表\" class=\"headerlink\" title=\"** git fetch origin。拉取远程分支列表\"></a>** git fetch origin。拉取远程分支列表</h3><table>\n<thead>\n<tr>\n<th>git branch</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>空</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-a</td>\n<td>查看全部焚毁</td>\n</tr>\n</tbody></table>\n<h1 id=\"撤销git-add-的方法-gt-git-restore\"><a href=\"#撤销git-add-的方法-gt-git-restore\" class=\"headerlink\" title=\"撤销git add . 的方法 -&gt; git restore .\"></a>撤销git add . 的方法 -&gt; git restore .</h1><h2 id=\"撤销git-commit-m-“注释”，\"><a href=\"#撤销git-commit-m-“注释”，\" class=\"headerlink\" title=\"撤销git commit -m “注释”，\"></a>撤销git commit -m “注释”，</h2><table>\n<thead>\n<tr>\n<th>git reset</th>\n<th>–hard</th>\n<th>删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>–mixed</td>\n<td>不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset –mixed HEAD^==git reset HEAD^</td>\n</tr>\n<tr>\n<td></td>\n<td>–sort</td>\n<td>不删除工作空间改动代码，不撤销git add ，撤销commit</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>–amend</td>\n<td>如果commit注释写错了，改一下注释</td>\n</tr>\n</tbody></table>\n<h2 id=\"推送仓库\"><a href=\"#推送仓库\" class=\"headerlink\" title=\"推送仓库\"></a>推送仓库</h2><table>\n<thead>\n<tr>\n<th>git push</th>\n<th>-u</th>\n<th>建立+推送远程分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>-f</td>\n<td>强制覆盖远程分支</td>\n</tr>\n</tbody></table>\n<h3 id=\"暂时存储工作区代码，（可以在分支间横跳代码）\"><a href=\"#暂时存储工作区代码，（可以在分支间横跳代码）\" class=\"headerlink\" title=\"暂时存储工作区代码，（可以在分支间横跳代码）\"></a>暂时存储工作区代码，（可以在分支间横跳代码）</h3><table>\n<thead>\n<tr>\n<th>git stash save “save message”</th>\n<th>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>git stash list</td>\n<td>查看stash了哪些存储</td>\n</tr>\n<tr>\n<td>git stash show</td>\n<td>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</td>\n</tr>\n<tr>\n<td>git stash show -p</td>\n<td>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</td>\n</tr>\n<tr>\n<td>git stash apply</td>\n<td>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</td>\n</tr>\n<tr>\n<td>git stash pop</td>\n<td>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</td>\n</tr>\n<tr>\n<td>git stash drop stash@{$num}</td>\n<td>丢弃stash@{$num}存储，从列表中删除这个存储</td>\n</tr>\n<tr>\n<td>git stash clear</td>\n<td>删除所有缓存的stash</td>\n</tr>\n</tbody></table>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><p>git branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。<br>git checkout -b test; 创建并切换到test分支</p>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><p>git branch -d test：删除本地test分支</p>\n<p>git branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。</p>\n<p>git push origin –delete test 删除远程test分支</p>\n<p>git push origin :test 删除远程test分支</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>branch</th>\n<th>空</th>\n<th>列出当前分支清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-a</td>\n<td>查看远程分支和本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-v</td>\n<td>查看各个分支最后一个提交信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–merged</td>\n<td>查看哪些分支已经合并入当前分支</td>\n</tr>\n</tbody></table>\n<h1 id=\"拉取分支\"><a href=\"#拉取分支\" class=\"headerlink\" title=\"拉取分支\"></a>拉取分支</h1><p>git fetch origin 同步远程服务器的数据到本地</p>\n<p>git checkout -b test origin/test_remote 将远程分支test_remote拉取下来到本地test分支</p>\n<p>git checkout test 将远程分支test拉取下来到本地test分支</p>\n<p>git pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test</p>\n<h2 id=\"git-merge的参数\"><a href=\"#git-merge的参数\" class=\"headerlink\" title=\"git merge的参数\"></a>git merge的参数</h2><p>merge的两个分支要有历史关联，没有的话需要添加git merge master –allow-unrelated-histories，参数。</p>\n<table>\n<thead>\n<tr>\n<th>git</th>\n<th>merge</th>\n<th></th>\n<th>合并分支到当前分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>–ff</td>\n<td>快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–ff-only</td>\n<td>只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–no-ff</td>\n<td>不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–squash</td>\n<td>压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来</td>\n</tr>\n</tbody></table>\n<h2 id=\"git-rebase的参数\"><a href=\"#git-rebase的参数\" class=\"headerlink\" title=\"git rebase的参数\"></a>git rebase的参数</h2><table>\n<thead>\n<tr>\n<th>git</th>\n<th>rebase</th>\n<th>分布湿合并分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i HEAD~num</td>\n<td>合并后num个commit记录</td>\n<td>p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>左开右闭</td>\n<td>start和end分别代码commit id</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>onto [newbase]</td>\n<td>将部分分支复制到新commit上，实现中间一大段commit的删除</td>\n</tr>\n<tr>\n<td>通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"gitrebase.png\" alt=\"截屏2021-12-01 18.38.28.png\"><br>在用d时可删除部分分支。s时前面得有pick，<br>本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</p>\n<h3 id=\"复制部分分支\"><a href=\"#复制部分分支\" class=\"headerlink\" title=\"复制部分分支\"></a>复制部分分支</h3><p>git rebase [startpoint] [endpoint] --onto [branchName] （[startpoint] [endpoint]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）<br>运行git rebase –continue命令继续变基。<br>运行git rebase –abort命令回到rebase之前的状态。<br>个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。</p>\n<h1 id=\"git-commit-记录查询\"><a href=\"#git-commit-记录查询\" class=\"headerlink\" title=\"git commit 记录查询\"></a>git commit 记录查询</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>show</th>\n<th>空</th>\n<th>.查看最新的commit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>commitId</td>\n<td>.查看指定commit hashID的所有修改：</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>commitId fileName</td>\n<td>.查看某次commit中具体某个文件的修改：</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h1><p>git init</p>\n<h2 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库\"></a>克隆仓库</h2><p>git clone git地址</p>\n<h2 id=\"设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\"><a href=\"#设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\" class=\"headerlink\" title=\"设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)\"></a>设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)</h2><p>git config –global user,name “用户名”<br>git config –global user.email “用户邮箱”</p>\n<h2 id=\"链接远程仓库\"><a href=\"#链接远程仓库\" class=\"headerlink\" title=\"链接远程仓库\"></a>链接远程仓库</h2><p>git remote add origin git地址</p>\n<h3 id=\"当修改密码后需要git-push-时报http-denied错误时\"><a href=\"#当修改密码后需要git-push-时报http-denied错误时\" class=\"headerlink\" title=\"当修改密码后需要git push 时报http denied错误时\"></a>当修改密码后需要git push 时报http denied错误时</h3><p>输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）<br>或<br>git config –global http.emptyAuth true </p>\n<h3 id=\"当本地查看远程分支时\"><a href=\"#当本地查看远程分支时\" class=\"headerlink\" title=\"当本地查看远程分支时\"></a>当本地查看远程分支时</h3><h3 id=\"git-fetch-origin。拉取远程分支列表\"><a href=\"#git-fetch-origin。拉取远程分支列表\" class=\"headerlink\" title=\"** git fetch origin。拉取远程分支列表\"></a>** git fetch origin。拉取远程分支列表</h3><table>\n<thead>\n<tr>\n<th>git branch</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>空</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-a</td>\n<td>查看全部焚毁</td>\n</tr>\n</tbody></table>\n<h1 id=\"撤销git-add-的方法-gt-git-restore\"><a href=\"#撤销git-add-的方法-gt-git-restore\" class=\"headerlink\" title=\"撤销git add . 的方法 -&gt; git restore .\"></a>撤销git add . 的方法 -&gt; git restore .</h1><h2 id=\"撤销git-commit-m-“注释”，\"><a href=\"#撤销git-commit-m-“注释”，\" class=\"headerlink\" title=\"撤销git commit -m “注释”，\"></a>撤销git commit -m “注释”，</h2><table>\n<thead>\n<tr>\n<th>git reset</th>\n<th>–hard</th>\n<th>删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>–mixed</td>\n<td>不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset –mixed HEAD^==git reset HEAD^</td>\n</tr>\n<tr>\n<td></td>\n<td>–sort</td>\n<td>不删除工作空间改动代码，不撤销git add ，撤销commit</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>–amend</td>\n<td>如果commit注释写错了，改一下注释</td>\n</tr>\n</tbody></table>\n<h2 id=\"推送仓库\"><a href=\"#推送仓库\" class=\"headerlink\" title=\"推送仓库\"></a>推送仓库</h2><table>\n<thead>\n<tr>\n<th>git push</th>\n<th>-u</th>\n<th>建立+推送远程分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>-f</td>\n<td>强制覆盖远程分支</td>\n</tr>\n</tbody></table>\n<h3 id=\"暂时存储工作区代码，（可以在分支间横跳代码）\"><a href=\"#暂时存储工作区代码，（可以在分支间横跳代码）\" class=\"headerlink\" title=\"暂时存储工作区代码，（可以在分支间横跳代码）\"></a>暂时存储工作区代码，（可以在分支间横跳代码）</h3><table>\n<thead>\n<tr>\n<th>git stash save “save message”</th>\n<th>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>git stash list</td>\n<td>查看stash了哪些存储</td>\n</tr>\n<tr>\n<td>git stash show</td>\n<td>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</td>\n</tr>\n<tr>\n<td>git stash show -p</td>\n<td>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</td>\n</tr>\n<tr>\n<td>git stash apply</td>\n<td>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</td>\n</tr>\n<tr>\n<td>git stash pop</td>\n<td>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</td>\n</tr>\n<tr>\n<td>git stash drop stash@{$num}</td>\n<td>丢弃stash@{$num}存储，从列表中删除这个存储</td>\n</tr>\n<tr>\n<td>git stash clear</td>\n<td>删除所有缓存的stash</td>\n</tr>\n</tbody></table>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><p>git branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。<br>git checkout -b test; 创建并切换到test分支</p>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><p>git branch -d test：删除本地test分支</p>\n<p>git branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。</p>\n<p>git push origin –delete test 删除远程test分支</p>\n<p>git push origin :test 删除远程test分支</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>branch</th>\n<th>空</th>\n<th>列出当前分支清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-a</td>\n<td>查看远程分支和本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-v</td>\n<td>查看各个分支最后一个提交信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–merged</td>\n<td>查看哪些分支已经合并入当前分支</td>\n</tr>\n</tbody></table>\n<h1 id=\"拉取分支\"><a href=\"#拉取分支\" class=\"headerlink\" title=\"拉取分支\"></a>拉取分支</h1><p>git fetch origin 同步远程服务器的数据到本地</p>\n<p>git checkout -b test origin/test_remote 将远程分支test_remote拉取下来到本地test分支</p>\n<p>git checkout test 将远程分支test拉取下来到本地test分支</p>\n<p>git pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test</p>\n<h2 id=\"git-merge的参数\"><a href=\"#git-merge的参数\" class=\"headerlink\" title=\"git merge的参数\"></a>git merge的参数</h2><p>merge的两个分支要有历史关联，没有的话需要添加git merge master –allow-unrelated-histories，参数。</p>\n<table>\n<thead>\n<tr>\n<th>git</th>\n<th>merge</th>\n<th></th>\n<th>合并分支到当前分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>–ff</td>\n<td>快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–ff-only</td>\n<td>只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–no-ff</td>\n<td>不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–squash</td>\n<td>压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来</td>\n</tr>\n</tbody></table>\n<h2 id=\"git-rebase的参数\"><a href=\"#git-rebase的参数\" class=\"headerlink\" title=\"git rebase的参数\"></a>git rebase的参数</h2><table>\n<thead>\n<tr>\n<th>git</th>\n<th>rebase</th>\n<th>分布湿合并分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i HEAD~num</td>\n<td>合并后num个commit记录</td>\n<td>p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>左开右闭</td>\n<td>start和end分别代码commit id</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>onto [newbase]</td>\n<td>将部分分支复制到新commit上，实现中间一大段commit的删除</td>\n</tr>\n<tr>\n<td>通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"gitrebase.png\" alt=\"截屏2021-12-01 18.38.28.png\"><br>在用d时可删除部分分支。s时前面得有pick，<br>本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</p>\n<h3 id=\"复制部分分支\"><a href=\"#复制部分分支\" class=\"headerlink\" title=\"复制部分分支\"></a>复制部分分支</h3><p>git rebase [startpoint] [endpoint] --onto [branchName] （[startpoint] [endpoint]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）<br>运行git rebase –continue命令继续变基。<br>运行git rebase –abort命令回到rebase之前的状态。<br>个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。</p>\n<h1 id=\"git-commit-记录查询\"><a href=\"#git-commit-记录查询\" class=\"headerlink\" title=\"git commit 记录查询\"></a>git commit 记录查询</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>show</th>\n<th>空</th>\n<th>.查看最新的commit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>commitId</td>\n<td>.查看指定commit hashID的所有修改：</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>commitId fileName</td>\n<td>.查看某次commit中具体某个文件的修改：</td>\n</tr>\n</tbody></table>\n"},{"title":"graphql看懂这篇直接开发","date":"2022-08-28T09:44:15.000Z","_content":"# graphql的初尝\n\n## graphql\n\n### graphql在实战中踩坑\n\n- react-hoc(higherOrderComponent)\n\n\t- name\n\n\t\t- 改变返回值的名称\n\t\t- 定义mutate操作的名称\n\t\t- 此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。\n\n\t\t\t- export default graphName.HOC({name:'yourdefinedFunctionName',props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=>{return {yourdefinedFunctionName,refetch,variables})\n\n\t- props\n\n\t\t- 参数为请求返回来的数据，若没有name，默认为data\n\t\t- 返回值为传给子组件的props，merge方式\n\n\t\t\t- const {yourdefinedFunctionName} = props\n\n\t- options\n\n\t\t- 参数为父组件传进来的数据\n\t\t- 返回值为发起请求中的参数\n\t\t- 值为对象或函数\n\n\t\t\t- options: props=>{const {id} = props return {variables:{id}}\n\n\t- skip\n\n\t\t- export default graphql(gql`{ ... }`, {\n  skip: props => !!props.skip,\n})(MyComponent);\n\t\t- 值为布尔值或函数，\n\n\t\t\t- true\n\n\t\t\t\t- 跳过该graphql\n\n\t\t\t\t\t- 应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用\n\n\t\t\t- 函数，\n\n\t\t\t\t- 参数为父组件传入的props\n\t\t\t\t- 返回值为true/flase\n\n\t- withref\n\n\t\t- 通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。\n\n\t- alias\n\n\t\t- 配置高阶组件包装器的名称\n\t\t- 主要用于devtool来判断当前的组件名称，排错时用的\n\n- 理论\n\n\t- GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。\n\n\t- 按需整合返回的数据\n\n- 与restful的区别\n\n\t- 资源\n\n\t\t- 相同点\n\n\t\t\t- 都有资源这个概念，而且都能通过ID去获取资源。\n\t\t\t- 都可以通过HTTP GET方式来获取资源。\n\t\t\t- 都可以使用JSON作为响应格式。\n\n\t\t- 不同点\n\n\t\t\t- 在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关\n\t\t\t- 在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源\n\n\t- 路由\n\n\t\t- 相同点\n\n\t\t\t- REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。\n\t\t\t- 都能用不同的方式描述一个API请求到底是读操作还是写操作。\n\n\t\t- 不同点\n\n\t\t\t- GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。\n\t\t\t- 在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。\n\t\t\t- REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。\n\n\t- 解析器\n\n\t\t- 相同点\n\n\t\t\t- REST的端点与GraphQL查询字段都在服务端调起函数执行。\n\t\t\t- REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。\n\n\t\t- 不同点\n\n\t\t\t- 一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。\n\t\t\t- REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。\n\n- 截屏2022-06-30 11.54.48.png\n\n### 参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\n\n","source":"_posts/graphql看懂这篇直接开发.md","raw":"---\ntitle: graphql看懂这篇直接开发\ndate: 2022-08-28 17:44:15\ntags: 持续更新（ing）\n---\n# graphql的初尝\n\n## graphql\n\n### graphql在实战中踩坑\n\n- react-hoc(higherOrderComponent)\n\n\t- name\n\n\t\t- 改变返回值的名称\n\t\t- 定义mutate操作的名称\n\t\t- 此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。\n\n\t\t\t- export default graphName.HOC({name:'yourdefinedFunctionName',props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=>{return {yourdefinedFunctionName,refetch,variables})\n\n\t- props\n\n\t\t- 参数为请求返回来的数据，若没有name，默认为data\n\t\t- 返回值为传给子组件的props，merge方式\n\n\t\t\t- const {yourdefinedFunctionName} = props\n\n\t- options\n\n\t\t- 参数为父组件传进来的数据\n\t\t- 返回值为发起请求中的参数\n\t\t- 值为对象或函数\n\n\t\t\t- options: props=>{const {id} = props return {variables:{id}}\n\n\t- skip\n\n\t\t- export default graphql(gql`{ ... }`, {\n  skip: props => !!props.skip,\n})(MyComponent);\n\t\t- 值为布尔值或函数，\n\n\t\t\t- true\n\n\t\t\t\t- 跳过该graphql\n\n\t\t\t\t\t- 应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用\n\n\t\t\t- 函数，\n\n\t\t\t\t- 参数为父组件传入的props\n\t\t\t\t- 返回值为true/flase\n\n\t- withref\n\n\t\t- 通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。\n\n\t- alias\n\n\t\t- 配置高阶组件包装器的名称\n\t\t- 主要用于devtool来判断当前的组件名称，排错时用的\n\n- 理论\n\n\t- GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。\n\n\t- 按需整合返回的数据\n\n- 与restful的区别\n\n\t- 资源\n\n\t\t- 相同点\n\n\t\t\t- 都有资源这个概念，而且都能通过ID去获取资源。\n\t\t\t- 都可以通过HTTP GET方式来获取资源。\n\t\t\t- 都可以使用JSON作为响应格式。\n\n\t\t- 不同点\n\n\t\t\t- 在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关\n\t\t\t- 在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源\n\n\t- 路由\n\n\t\t- 相同点\n\n\t\t\t- REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。\n\t\t\t- 都能用不同的方式描述一个API请求到底是读操作还是写操作。\n\n\t\t- 不同点\n\n\t\t\t- GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。\n\t\t\t- 在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。\n\t\t\t- REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。\n\n\t- 解析器\n\n\t\t- 相同点\n\n\t\t\t- REST的端点与GraphQL查询字段都在服务端调起函数执行。\n\t\t\t- REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。\n\n\t\t- 不同点\n\n\t\t\t- 一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。\n\t\t\t- REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。\n\n- 截屏2022-06-30 11.54.48.png\n\n### 参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\n\n","slug":"graphql看懂这篇直接开发","published":1,"updated":"2025-06-22T01:39:55.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc703iqm0001wvtkgiwf9yy9","content":"<h1 id=\"graphql的初尝\"><a href=\"#graphql的初尝\" class=\"headerlink\" title=\"graphql的初尝\"></a>graphql的初尝</h1><h2 id=\"graphql\"><a href=\"#graphql\" class=\"headerlink\" title=\"graphql\"></a>graphql</h2><h3 id=\"graphql在实战中踩坑\"><a href=\"#graphql在实战中踩坑\" class=\"headerlink\" title=\"graphql在实战中踩坑\"></a>graphql在实战中踩坑</h3><ul>\n<li><p>react-hoc(higherOrderComponent)</p>\n<ul>\n<li><p>name</p>\n<ul>\n<li><p>改变返回值的名称</p>\n</li>\n<li><p>定义mutate操作的名称</p>\n</li>\n<li><p>此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。</p>\n<ul>\n<li>export default graphName.HOC({name:’yourdefinedFunctionName’,props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=&gt;{return {yourdefinedFunctionName,refetch,variables})</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>props</p>\n<ul>\n<li><p>参数为请求返回来的数据，若没有name，默认为data</p>\n</li>\n<li><p>返回值为传给子组件的props，merge方式</p>\n<ul>\n<li>const {yourdefinedFunctionName} = props</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>options</p>\n<ul>\n<li><p>参数为父组件传进来的数据</p>\n</li>\n<li><p>返回值为发起请求中的参数</p>\n</li>\n<li><p>值为对象或函数</p>\n<ul>\n<li>options: props=&gt;{const {id} = props return {variables:{id}}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>skip</p>\n<ul>\n<li><p>export default graphql(gql<code>&#123; ... &#125;</code>, {<br>skip: props =&gt; !!props.skip,<br>})(MyComponent);</p>\n</li>\n<li><p>值为布尔值或函数，</p>\n<ul>\n<li><p>true</p>\n<ul>\n<li><p>跳过该graphql</p>\n<ul>\n<li>应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>函数，</p>\n<ul>\n<li>参数为父组件传入的props</li>\n<li>返回值为true/flase</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>withref</p>\n<ul>\n<li>通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。</li>\n</ul>\n</li>\n<li><p>alias</p>\n<ul>\n<li>配置高阶组件包装器的名称</li>\n<li>主要用于devtool来判断当前的组件名称，排错时用的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>理论</p>\n<ul>\n<li><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。</p>\n</li>\n<li><p>按需整合返回的数据</p>\n</li>\n</ul>\n</li>\n<li><p>与restful的区别</p>\n<ul>\n<li><p>资源</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>都有资源这个概念，而且都能通过ID去获取资源。</li>\n<li>都可以通过HTTP GET方式来获取资源。</li>\n<li>都可以使用JSON作为响应格式。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关</li>\n<li>在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。</li>\n<li>都能用不同的方式描述一个API请求到底是读操作还是写操作。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。</li>\n<li>在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。</li>\n<li>REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解析器</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST的端点与GraphQL查询字段都在服务端调起函数执行。</li>\n<li>REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。</li>\n<li>REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>截屏2022-06-30 11.54.48.png</p>\n</li>\n</ul>\n<h3 id=\"参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\"><a href=\"#参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\" class=\"headerlink\" title=\"参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\"></a>参考网址：<a href=\"https://www.apollographql.com/docs/react/v2/api/react-hoc\">https://www.apollographql.com/docs/react/v2/api/react-hoc</a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"graphql的初尝\"><a href=\"#graphql的初尝\" class=\"headerlink\" title=\"graphql的初尝\"></a>graphql的初尝</h1><h2 id=\"graphql\"><a href=\"#graphql\" class=\"headerlink\" title=\"graphql\"></a>graphql</h2><h3 id=\"graphql在实战中踩坑\"><a href=\"#graphql在实战中踩坑\" class=\"headerlink\" title=\"graphql在实战中踩坑\"></a>graphql在实战中踩坑</h3><ul>\n<li><p>react-hoc(higherOrderComponent)</p>\n<ul>\n<li><p>name</p>\n<ul>\n<li><p>改变返回值的名称</p>\n</li>\n<li><p>定义mutate操作的名称</p>\n</li>\n<li><p>此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。</p>\n<ul>\n<li>export default graphName.HOC({name:’yourdefinedFunctionName’,props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=&gt;{return {yourdefinedFunctionName,refetch,variables})</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>props</p>\n<ul>\n<li><p>参数为请求返回来的数据，若没有name，默认为data</p>\n</li>\n<li><p>返回值为传给子组件的props，merge方式</p>\n<ul>\n<li>const {yourdefinedFunctionName} = props</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>options</p>\n<ul>\n<li><p>参数为父组件传进来的数据</p>\n</li>\n<li><p>返回值为发起请求中的参数</p>\n</li>\n<li><p>值为对象或函数</p>\n<ul>\n<li>options: props=&gt;{const {id} = props return {variables:{id}}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>skip</p>\n<ul>\n<li><p>export default graphql(gql<code>&#123; ... &#125;</code>, {<br>skip: props =&gt; !!props.skip,<br>})(MyComponent);</p>\n</li>\n<li><p>值为布尔值或函数，</p>\n<ul>\n<li><p>true</p>\n<ul>\n<li><p>跳过该graphql</p>\n<ul>\n<li>应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>函数，</p>\n<ul>\n<li>参数为父组件传入的props</li>\n<li>返回值为true/flase</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>withref</p>\n<ul>\n<li>通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。</li>\n</ul>\n</li>\n<li><p>alias</p>\n<ul>\n<li>配置高阶组件包装器的名称</li>\n<li>主要用于devtool来判断当前的组件名称，排错时用的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>理论</p>\n<ul>\n<li><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。</p>\n</li>\n<li><p>按需整合返回的数据</p>\n</li>\n</ul>\n</li>\n<li><p>与restful的区别</p>\n<ul>\n<li><p>资源</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>都有资源这个概念，而且都能通过ID去获取资源。</li>\n<li>都可以通过HTTP GET方式来获取资源。</li>\n<li>都可以使用JSON作为响应格式。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关</li>\n<li>在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。</li>\n<li>都能用不同的方式描述一个API请求到底是读操作还是写操作。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。</li>\n<li>在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。</li>\n<li>REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解析器</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST的端点与GraphQL查询字段都在服务端调起函数执行。</li>\n<li>REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。</li>\n<li>REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>截屏2022-06-30 11.54.48.png</p>\n</li>\n</ul>\n<h3 id=\"参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\"><a href=\"#参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\" class=\"headerlink\" title=\"参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\"></a>参考网址：<a href=\"https://www.apollographql.com/docs/react/v2/api/react-hoc\">https://www.apollographql.com/docs/react/v2/api/react-hoc</a></h3>"},{"title":"检测后端接口常见方法","date":"2022-05-22T14:36:45.000Z","comments":1,"_content":"### 痛点，常常由于不知道后端接口是否可用而苦恼\n#### 方法一：curl实现，post请求\n    1、复制浏览器的curl链接，\n    2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    3、删除掉原有的orgin和referer字段，\n    -H 请求头\n    --data-row：请求体\n    -x：请求协议\n#### 方法二：通过浏览器网址直接访问，get请求\n    1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    容易由于鉴权问题出现错误。\n#### 方法三：通过postman调用接口\n    1、配置后端的域名和接口地址环境\n    2、配置请求头\n    3、配置请求体","source":"_posts/检测后端接口常见方法.md","raw":"---\ntitle: 检测后端接口常见方法\ndate: 2022-05-22 22:36:45\ntags: 后端接口\ncategories: 后端接口\ncomments: true\n---\n### 痛点，常常由于不知道后端接口是否可用而苦恼\n#### 方法一：curl实现，post请求\n    1、复制浏览器的curl链接，\n    2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    3、删除掉原有的orgin和referer字段，\n    -H 请求头\n    --data-row：请求体\n    -x：请求协议\n#### 方法二：通过浏览器网址直接访问，get请求\n    1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    容易由于鉴权问题出现错误。\n#### 方法三：通过postman调用接口\n    1、配置后端的域名和接口地址环境\n    2、配置请求头\n    3、配置请求体","slug":"检测后端接口常见方法","published":1,"updated":"2025-06-22T01:39:55.186Z","layout":"post","photos":[],"link":"","_id":"cmc703iqp0004wvtk27390ltq","content":"<h3 id=\"痛点，常常由于不知道后端接口是否可用而苦恼\"><a href=\"#痛点，常常由于不知道后端接口是否可用而苦恼\" class=\"headerlink\" title=\"痛点，常常由于不知道后端接口是否可用而苦恼\"></a>痛点，常常由于不知道后端接口是否可用而苦恼</h3><h4 id=\"方法一：curl实现，post请求\"><a href=\"#方法一：curl实现，post请求\" class=\"headerlink\" title=\"方法一：curl实现，post请求\"></a>方法一：curl实现，post请求</h4><pre><code>1、复制浏览器的curl链接，\n2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n3、删除掉原有的orgin和referer字段，\n-H 请求头\n--data-row：请求体\n-x：请求协议\n</code></pre>\n<h4 id=\"方法二：通过浏览器网址直接访问，get请求\"><a href=\"#方法二：通过浏览器网址直接访问，get请求\" class=\"headerlink\" title=\"方法二：通过浏览器网址直接访问，get请求\"></a>方法二：通过浏览器网址直接访问，get请求</h4><pre><code>1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n容易由于鉴权问题出现错误。\n</code></pre>\n<h4 id=\"方法三：通过postman调用接口\"><a href=\"#方法三：通过postman调用接口\" class=\"headerlink\" title=\"方法三：通过postman调用接口\"></a>方法三：通过postman调用接口</h4><pre><code>1、配置后端的域名和接口地址环境\n2、配置请求头\n3、配置请求体\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"痛点，常常由于不知道后端接口是否可用而苦恼\"><a href=\"#痛点，常常由于不知道后端接口是否可用而苦恼\" class=\"headerlink\" title=\"痛点，常常由于不知道后端接口是否可用而苦恼\"></a>痛点，常常由于不知道后端接口是否可用而苦恼</h3><h4 id=\"方法一：curl实现，post请求\"><a href=\"#方法一：curl实现，post请求\" class=\"headerlink\" title=\"方法一：curl实现，post请求\"></a>方法一：curl实现，post请求</h4><pre><code>1、复制浏览器的curl链接，\n2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n3、删除掉原有的orgin和referer字段，\n-H 请求头\n--data-row：请求体\n-x：请求协议\n</code></pre>\n<h4 id=\"方法二：通过浏览器网址直接访问，get请求\"><a href=\"#方法二：通过浏览器网址直接访问，get请求\" class=\"headerlink\" title=\"方法二：通过浏览器网址直接访问，get请求\"></a>方法二：通过浏览器网址直接访问，get请求</h4><pre><code>1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n容易由于鉴权问题出现错误。\n</code></pre>\n<h4 id=\"方法三：通过postman调用接口\"><a href=\"#方法三：通过postman调用接口\" class=\"headerlink\" title=\"方法三：通过postman调用接口\"></a>方法三：通过postman调用接口</h4><pre><code>1、配置后端的域名和接口地址环境\n2、配置请求头\n3、配置请求体\n</code></pre>\n"},{"title":"react前端下载后端返回的文件方法（url、二进制流）","date":"2022-05-22T14:41:02.000Z","comments":1,"_content":"### 前端下载文件有两种方式：\n1、通过后端返回的url，前端通过window.open(url);\n2、后端返回的是二进制流，通过a标签实现下载。\n##### 方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\n##### 方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\n```\naxios({\n      method: 'post',\n      url: '/api/trust/auditDownload', //此处放hobber的内部的url\n      data: params,\n      responseType: 'arraybuffer', // 需要制定返回的类型，否则下载的文件会乱码\n    }).then(res => {\n      // 假设 data 是返回来的二进制数据\n      const data = res.data;\n      const url = window.URL.createObjectURL( // type指定下载的文件的格式\n        new Blob([data], {\n          type:\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        }),\n      );\n      const link = document.createElement('a');\n      link.style.display = 'none';\n      link.href = url;\n      link.setAttribute('download', 'excel.xlsx'); // 设置下载的文件名\n      document.body.appendChild(link); \n      link.click(); // 触发a标签\n      document.body.removeChild(link); // 删除标签\n    });\n```\n##### 方法三、将二进制数据封装为文件读取FileReader对象\n```\n// utils.js\nexport const download = (res) => {\n  // 创建文件对象\n  let reader = new FileReader()\n  // 监听读取完毕\n  reader.onloadend = function () {\n    // 返回base64位的文件内容\n    let url = reader.result\n    // 下载\n    window.location.href = url\n  }\n  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\n  reader.readAsDataURL(res)\n}\n```\n注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。\n\n##### 方法四、使用插件file-saver\n下载插件\n```\n npm install --save file-saver\n```\n引入插件\n```\n import { saveAs } from 'file-saver'\n```\n封装下载方法，使用插件\n```\n export const downloadFile = (res, type, filename) => {\n   // 将二进制数据封装成blob对象\n    const blob = new Blob([res], {\n     type: type\n   })\n   /**\n     这里也可以使用File对象封装二进制数据\n     const file = new File([res], filename, {\n       type: type\n     });\n   */\n   // 调用插件方法\n   saveAs(blob,filename)\n }\n```\n[插件源码](https://github.com/eligrey/FileSaver.js)\n##### 方法五、使用插件downloadjs\n下载插件\n```\n npm install --save downloadjs\n```\n引入插件\n```\n const download = require('downloadjs')\n```\n因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。\n\n封装下载方法，使用插件\n```\n  export const downloadFile = (res, type, filename) => {\n    // 将二进制流转成blob对象\n    const blob = new Blob([res], {\n      type: type\n    })\n    // 调用插件方法\n    download(blob, filename, type);\n  }\n\n```\n[插件源码](https://github.com/rndme/download)\n##### 二、发送请求，获取二进制流数据\n```\n// index.vue\n<template>\n  <div>\n    <button @click='handleDownload'>下载</button>\n  </div>\n</template>\n<script>\n// 引入下载方法\nimport {download} from 'utils'\nexport default{\n  methods: {\n    async downloadFile () {\n      let res = await axios.get(\n        url: 'xxxx/xxxx',\n        method: 'GET',\n        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`\n        responseType: 'blob',\n        params: {\n          id: 'xxxxxx'\n        }\n      )\n      // 获取在response headers中返回的下载文件类型\n      let type = JSON.parse(res.headers)['content-type']\n      \n      /*获取在response headers中返回的下载文件名\n        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码\n      */\n      let fileName = decodeURIComponent(JSON.parse(res.headers)['file-name'])\n      // 调用封装好的下载函数\n      download(res, type, fileName)\n    },\n    // 点击下载按钮下载\n    handleDownload() {\n      this.downloadFile()\n    }\n  }\n}\n</script>\n```\n##### 通过数据源拼接生产excel文件\n```\nconst outputExcel = () => {\n        let resultContent = 'A, B, C, D\\n'\n        let transferContent = resultContent => {\n            //根据数据 利用a标签模仿下载生成本地文件\n            let date = moment(new Date()).format('YYYY-MM-DD')\n            const blob = new Blob(['\\ufeff', resultContent], {\n                type: 'text/csv', // application/x-xls text/csv\n            })\n            const objectURL = window.URL.createObjectURL(blob)\n            const download = document.createElement('a')\n            download.href = objectURL\n            download.download = `${date}_${'文件名'}.${'csv'}`\n            download.click()\n            message.success('文件已下载')\n        }\n        let generateTxt = message => {\n            var element = document.createElement('a')\n            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(message))\n            element.setAttribute('download', '文件名' + new Date().getTime())\n            element.style.display = 'none'\n            document.body.appendChild(element)\n            element.click()\n            document.body.removeChild(element)\n        }\n        let current = 1,\n            pageSize = 8000\n\n        Modal.confirm({\n            title: '提示',\n            content: '确认导出全部信息吗？',\n            okText: '确认',\n            cancelText: '取消',\n            onOk: () => {\n                // 一次访问8000条数据的方案\n                refetch({\n                    filter: {},\n                    pager: { sort: '', current, pageSize },\n                    roleId,\n                }).then(values => {\n                    console.log('values', values)\n                    const total = values.data.allRoleUsers.total\n                    const nodes = values.data.allRoleUsers.nodes\n                    if (total > pageSize) {\n                        message.warning('用户数量太多')\n                    } else {\n                        for (let node of nodes) {\n                            let expireDate = moment(node['expireDate']).format('YYYY-MM-DD')\n                            if (expireDate === '9999-12-31') {\n                                expireDate = '永久有效'\n                            }\n                            resultContent +=\n                                node['A'] +\n                                ',' +\n                                node['B']['C'] +\n                                ',' +\n                                expireDate +\n                                ',' +\n                                moment(node['D']).format('YYYY-MM-DD') +\n                                '\\n'\n                        }\n                        // transferContent(resultContent)\n                        generateTxt(resultContent)\n                    }\n                })\n                // 轮询接口的方案\n                // const timer = setInterval(() => {\n                //     // console.log('current', current, Math.ceil(total / pageSize) + 1)\n                //     if (current < Math.ceil(total / pageSize) + 1) {\n                //         fetchMore({\n                //             variables: {\n                //                 filter: {},\n                //                 pager: { sort: '', current, pageSize },\n                //                 roleId,\n                //             },\n                //             updateQuery: (previousResult, { fetchMoreResult }) => {\n                //                 // console.log('previousResult', previousResult, fetchMoreResult)\n                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes\n                //                 for (let node of nodes) {\n                //                     resultContent +=\n                //                         node['A'] +\n                //                         ',' +\n                //                         node['B']['C'] +\n                //                         ',' +\n                //                         moment(node['D']).format('YYYY-MM-DD') +\n                //                         '\\n'\n                //                 }\n                //             },\n                //         })\n                //         current++\n                //     } else {\n                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示\n                //         const fileDateLines = resultContent.split('\\n').length - 1\n                //         if (fileDateLines === total + 1) {\n                //             transferContent(resultContent)\n                //         } else {\n                //             message.warning('数据量较大，导出数据出错，请联系管理员')\n                //         }\n                //         clearInterval(timer)\n                //     }\n                // }, 500)\n            },\n        })\n    }\n```","source":"_posts/react前端下载后端返回的文件方法（url、二进制流）.md","raw":"---\ntitle: react前端下载后端返回的文件方法（url、二进制流）\ndate: 2022-05-22 22:41:02\ntags: 前端调接口下载\ncategories: 下载\ncomments: true\n---\n### 前端下载文件有两种方式：\n1、通过后端返回的url，前端通过window.open(url);\n2、后端返回的是二进制流，通过a标签实现下载。\n##### 方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\n##### 方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\n```\naxios({\n      method: 'post',\n      url: '/api/trust/auditDownload', //此处放hobber的内部的url\n      data: params,\n      responseType: 'arraybuffer', // 需要制定返回的类型，否则下载的文件会乱码\n    }).then(res => {\n      // 假设 data 是返回来的二进制数据\n      const data = res.data;\n      const url = window.URL.createObjectURL( // type指定下载的文件的格式\n        new Blob([data], {\n          type:\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        }),\n      );\n      const link = document.createElement('a');\n      link.style.display = 'none';\n      link.href = url;\n      link.setAttribute('download', 'excel.xlsx'); // 设置下载的文件名\n      document.body.appendChild(link); \n      link.click(); // 触发a标签\n      document.body.removeChild(link); // 删除标签\n    });\n```\n##### 方法三、将二进制数据封装为文件读取FileReader对象\n```\n// utils.js\nexport const download = (res) => {\n  // 创建文件对象\n  let reader = new FileReader()\n  // 监听读取完毕\n  reader.onloadend = function () {\n    // 返回base64位的文件内容\n    let url = reader.result\n    // 下载\n    window.location.href = url\n  }\n  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\n  reader.readAsDataURL(res)\n}\n```\n注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。\n\n##### 方法四、使用插件file-saver\n下载插件\n```\n npm install --save file-saver\n```\n引入插件\n```\n import { saveAs } from 'file-saver'\n```\n封装下载方法，使用插件\n```\n export const downloadFile = (res, type, filename) => {\n   // 将二进制数据封装成blob对象\n    const blob = new Blob([res], {\n     type: type\n   })\n   /**\n     这里也可以使用File对象封装二进制数据\n     const file = new File([res], filename, {\n       type: type\n     });\n   */\n   // 调用插件方法\n   saveAs(blob,filename)\n }\n```\n[插件源码](https://github.com/eligrey/FileSaver.js)\n##### 方法五、使用插件downloadjs\n下载插件\n```\n npm install --save downloadjs\n```\n引入插件\n```\n const download = require('downloadjs')\n```\n因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。\n\n封装下载方法，使用插件\n```\n  export const downloadFile = (res, type, filename) => {\n    // 将二进制流转成blob对象\n    const blob = new Blob([res], {\n      type: type\n    })\n    // 调用插件方法\n    download(blob, filename, type);\n  }\n\n```\n[插件源码](https://github.com/rndme/download)\n##### 二、发送请求，获取二进制流数据\n```\n// index.vue\n<template>\n  <div>\n    <button @click='handleDownload'>下载</button>\n  </div>\n</template>\n<script>\n// 引入下载方法\nimport {download} from 'utils'\nexport default{\n  methods: {\n    async downloadFile () {\n      let res = await axios.get(\n        url: 'xxxx/xxxx',\n        method: 'GET',\n        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`\n        responseType: 'blob',\n        params: {\n          id: 'xxxxxx'\n        }\n      )\n      // 获取在response headers中返回的下载文件类型\n      let type = JSON.parse(res.headers)['content-type']\n      \n      /*获取在response headers中返回的下载文件名\n        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码\n      */\n      let fileName = decodeURIComponent(JSON.parse(res.headers)['file-name'])\n      // 调用封装好的下载函数\n      download(res, type, fileName)\n    },\n    // 点击下载按钮下载\n    handleDownload() {\n      this.downloadFile()\n    }\n  }\n}\n</script>\n```\n##### 通过数据源拼接生产excel文件\n```\nconst outputExcel = () => {\n        let resultContent = 'A, B, C, D\\n'\n        let transferContent = resultContent => {\n            //根据数据 利用a标签模仿下载生成本地文件\n            let date = moment(new Date()).format('YYYY-MM-DD')\n            const blob = new Blob(['\\ufeff', resultContent], {\n                type: 'text/csv', // application/x-xls text/csv\n            })\n            const objectURL = window.URL.createObjectURL(blob)\n            const download = document.createElement('a')\n            download.href = objectURL\n            download.download = `${date}_${'文件名'}.${'csv'}`\n            download.click()\n            message.success('文件已下载')\n        }\n        let generateTxt = message => {\n            var element = document.createElement('a')\n            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(message))\n            element.setAttribute('download', '文件名' + new Date().getTime())\n            element.style.display = 'none'\n            document.body.appendChild(element)\n            element.click()\n            document.body.removeChild(element)\n        }\n        let current = 1,\n            pageSize = 8000\n\n        Modal.confirm({\n            title: '提示',\n            content: '确认导出全部信息吗？',\n            okText: '确认',\n            cancelText: '取消',\n            onOk: () => {\n                // 一次访问8000条数据的方案\n                refetch({\n                    filter: {},\n                    pager: { sort: '', current, pageSize },\n                    roleId,\n                }).then(values => {\n                    console.log('values', values)\n                    const total = values.data.allRoleUsers.total\n                    const nodes = values.data.allRoleUsers.nodes\n                    if (total > pageSize) {\n                        message.warning('用户数量太多')\n                    } else {\n                        for (let node of nodes) {\n                            let expireDate = moment(node['expireDate']).format('YYYY-MM-DD')\n                            if (expireDate === '9999-12-31') {\n                                expireDate = '永久有效'\n                            }\n                            resultContent +=\n                                node['A'] +\n                                ',' +\n                                node['B']['C'] +\n                                ',' +\n                                expireDate +\n                                ',' +\n                                moment(node['D']).format('YYYY-MM-DD') +\n                                '\\n'\n                        }\n                        // transferContent(resultContent)\n                        generateTxt(resultContent)\n                    }\n                })\n                // 轮询接口的方案\n                // const timer = setInterval(() => {\n                //     // console.log('current', current, Math.ceil(total / pageSize) + 1)\n                //     if (current < Math.ceil(total / pageSize) + 1) {\n                //         fetchMore({\n                //             variables: {\n                //                 filter: {},\n                //                 pager: { sort: '', current, pageSize },\n                //                 roleId,\n                //             },\n                //             updateQuery: (previousResult, { fetchMoreResult }) => {\n                //                 // console.log('previousResult', previousResult, fetchMoreResult)\n                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes\n                //                 for (let node of nodes) {\n                //                     resultContent +=\n                //                         node['A'] +\n                //                         ',' +\n                //                         node['B']['C'] +\n                //                         ',' +\n                //                         moment(node['D']).format('YYYY-MM-DD') +\n                //                         '\\n'\n                //                 }\n                //             },\n                //         })\n                //         current++\n                //     } else {\n                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示\n                //         const fileDateLines = resultContent.split('\\n').length - 1\n                //         if (fileDateLines === total + 1) {\n                //             transferContent(resultContent)\n                //         } else {\n                //             message.warning('数据量较大，导出数据出错，请联系管理员')\n                //         }\n                //         clearInterval(timer)\n                //     }\n                // }, 500)\n            },\n        })\n    }\n```","slug":"react前端下载后端返回的文件方法（url、二进制流）","published":1,"updated":"2025-06-22T01:39:55.185Z","layout":"post","photos":[],"link":"","_id":"cmc703iqq0005wvtkbaadd4si","content":"<h3 id=\"前端下载文件有两种方式：\"><a href=\"#前端下载文件有两种方式：\" class=\"headerlink\" title=\"前端下载文件有两种方式：\"></a>前端下载文件有两种方式：</h3><p>1、通过后端返回的url，前端通过window.open(url);<br>2、后端返回的是二进制流，通过a标签实现下载。</p>\n<h5 id=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"><a href=\"#方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\" class=\"headerlink\" title=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"></a>方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。</h5><h5 id=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"><a href=\"#方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\" class=\"headerlink\" title=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"></a>方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">      method: &#x27;post&#x27;,</span><br><span class=\"line\">      url: &#x27;/api/trust/auditDownload&#x27;, //此处放hobber的内部的url</span><br><span class=\"line\">      data: params,</span><br><span class=\"line\">      responseType: &#x27;arraybuffer&#x27;, // 需要制定返回的类型，否则下载的文件会乱码</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">      // 假设 data 是返回来的二进制数据</span><br><span class=\"line\">      const data = res.data;</span><br><span class=\"line\">      const url = window.URL.createObjectURL( // type指定下载的文件的格式</span><br><span class=\"line\">        new Blob([data], &#123;</span><br><span class=\"line\">          type:</span><br><span class=\"line\">            &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">      const link = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">      link.style.display = &#x27;none&#x27;;</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.setAttribute(&#x27;download&#x27;, &#x27;excel.xlsx&#x27;); // 设置下载的文件名</span><br><span class=\"line\">      document.body.appendChild(link); </span><br><span class=\"line\">      link.click(); // 触发a标签</span><br><span class=\"line\">      document.body.removeChild(link); // 删除标签</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三、将二进制数据封装为文件读取FileReader对象\"><a href=\"#方法三、将二进制数据封装为文件读取FileReader对象\" class=\"headerlink\" title=\"方法三、将二进制数据封装为文件读取FileReader对象\"></a>方法三、将二进制数据封装为文件读取FileReader对象</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// utils.js</span><br><span class=\"line\">export const download = (res) =&gt; &#123;</span><br><span class=\"line\">  // 创建文件对象</span><br><span class=\"line\">  let reader = new FileReader()</span><br><span class=\"line\">  // 监听读取完毕</span><br><span class=\"line\">  reader.onloadend = function () &#123;</span><br><span class=\"line\">    // 返回base64位的文件内容</span><br><span class=\"line\">    let url = reader.result</span><br><span class=\"line\">    // 下载</span><br><span class=\"line\">    window.location.href = url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span><br><span class=\"line\">  reader.readAsDataURL(res)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。</p>\n<h5 id=\"方法四、使用插件file-saver\"><a href=\"#方法四、使用插件file-saver\" class=\"headerlink\" title=\"方法四、使用插件file-saver\"></a>方法四、使用插件file-saver</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save file-saver</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; saveAs &#125; from &#x27;file-saver&#x27;</span><br></pre></td></tr></table></figure>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制数据封装成blob对象</span><br><span class=\"line\">   const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  /**</span><br><span class=\"line\">    这里也可以使用File对象封装二进制数据</span><br><span class=\"line\">    const file = new File([res], filename, &#123;</span><br><span class=\"line\">      type: type</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  saveAs(blob,filename)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/eligrey/FileSaver.js\">插件源码</a></p>\n<h5 id=\"方法五、使用插件downloadjs\"><a href=\"#方法五、使用插件downloadjs\" class=\"headerlink\" title=\"方法五、使用插件downloadjs\"></a>方法五、使用插件downloadjs</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save downloadjs</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const download = require(&#x27;downloadjs&#x27;)</span><br></pre></td></tr></table></figure>\n<p>因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。</p>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制流转成blob对象</span><br><span class=\"line\">  const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  download(blob, filename, type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/rndme/download\">插件源码</a></p>\n<h5 id=\"二、发送请求，获取二进制流数据\"><a href=\"#二、发送请求，获取二进制流数据\" class=\"headerlink\" title=\"二、发送请求，获取二进制流数据\"></a>二、发送请求，获取二进制流数据</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;button @click=&#x27;handleDownload&#x27;&gt;下载&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 引入下载方法</span><br><span class=\"line\">import &#123;download&#125; from &#x27;utils&#x27;</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    async downloadFile () &#123;</span><br><span class=\"line\">      let res = await axios.get(</span><br><span class=\"line\">        url: &#x27;xxxx/xxxx&#x27;,</span><br><span class=\"line\">        method: &#x27;GET&#x27;,</span><br><span class=\"line\">        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`</span><br><span class=\"line\">        responseType: &#x27;blob&#x27;,</span><br><span class=\"line\">        params: &#123;</span><br><span class=\"line\">          id: &#x27;xxxxxx&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      // 获取在response headers中返回的下载文件类型</span><br><span class=\"line\">      let type = JSON.parse(res.headers)[&#x27;content-type&#x27;]</span><br><span class=\"line\">      </span><br><span class=\"line\">      /*获取在response headers中返回的下载文件名</span><br><span class=\"line\">        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码</span><br><span class=\"line\">      */</span><br><span class=\"line\">      let fileName = decodeURIComponent(JSON.parse(res.headers)[&#x27;file-name&#x27;])</span><br><span class=\"line\">      // 调用封装好的下载函数</span><br><span class=\"line\">      download(res, type, fileName)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 点击下载按钮下载</span><br><span class=\"line\">    handleDownload() &#123;</span><br><span class=\"line\">      this.downloadFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过数据源拼接生产excel文件\"><a href=\"#通过数据源拼接生产excel文件\" class=\"headerlink\" title=\"通过数据源拼接生产excel文件\"></a>通过数据源拼接生产excel文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const outputExcel = () =&gt; &#123;</span><br><span class=\"line\">        let resultContent = &#x27;A, B, C, D\\n&#x27;</span><br><span class=\"line\">        let transferContent = resultContent =&gt; &#123;</span><br><span class=\"line\">            //根据数据 利用a标签模仿下载生成本地文件</span><br><span class=\"line\">            let date = moment(new Date()).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">            const blob = new Blob([&#x27;\\ufeff&#x27;, resultContent], &#123;</span><br><span class=\"line\">                type: &#x27;text/csv&#x27;, // application/x-xls text/csv</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            const objectURL = window.URL.createObjectURL(blob)</span><br><span class=\"line\">            const download = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            download.href = objectURL</span><br><span class=\"line\">            download.download = `$&#123;date&#125;_$&#123;&#x27;文件名&#x27;&#125;.$&#123;&#x27;csv&#x27;&#125;`</span><br><span class=\"line\">            download.click()</span><br><span class=\"line\">            message.success(&#x27;文件已下载&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let generateTxt = message =&gt; &#123;</span><br><span class=\"line\">            var element = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            element.setAttribute(&#x27;href&#x27;, &#x27;data:text/plain;charset=utf-8,&#x27; + encodeURIComponent(message))</span><br><span class=\"line\">            element.setAttribute(&#x27;download&#x27;, &#x27;文件名&#x27; + new Date().getTime())</span><br><span class=\"line\">            element.style.display = &#x27;none&#x27;</span><br><span class=\"line\">            document.body.appendChild(element)</span><br><span class=\"line\">            element.click()</span><br><span class=\"line\">            document.body.removeChild(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let current = 1,</span><br><span class=\"line\">            pageSize = 8000</span><br><span class=\"line\"></span><br><span class=\"line\">        Modal.confirm(&#123;</span><br><span class=\"line\">            title: &#x27;提示&#x27;,</span><br><span class=\"line\">            content: &#x27;确认导出全部信息吗？&#x27;,</span><br><span class=\"line\">            okText: &#x27;确认&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">                // 一次访问8000条数据的方案</span><br><span class=\"line\">                refetch(&#123;</span><br><span class=\"line\">                    filter: &#123;&#125;,</span><br><span class=\"line\">                    pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                    roleId,</span><br><span class=\"line\">                &#125;).then(values =&gt; &#123;</span><br><span class=\"line\">                    console.log(&#x27;values&#x27;, values)</span><br><span class=\"line\">                    const total = values.data.allRoleUsers.total</span><br><span class=\"line\">                    const nodes = values.data.allRoleUsers.nodes</span><br><span class=\"line\">                    if (total &gt; pageSize) &#123;</span><br><span class=\"line\">                        message.warning(&#x27;用户数量太多&#x27;)</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        for (let node of nodes) &#123;</span><br><span class=\"line\">                            let expireDate = moment(node[&#x27;expireDate&#x27;]).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">                            if (expireDate === &#x27;9999-12-31&#x27;) &#123;</span><br><span class=\"line\">                                expireDate = &#x27;永久有效&#x27;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            resultContent +=</span><br><span class=\"line\">                                node[&#x27;A&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                expireDate +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                                &#x27;\\n&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // transferContent(resultContent)</span><br><span class=\"line\">                        generateTxt(resultContent)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                // 轮询接口的方案</span><br><span class=\"line\">                // const timer = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                //     // console.log(&#x27;current&#x27;, current, Math.ceil(total / pageSize) + 1)</span><br><span class=\"line\">                //     if (current &lt; Math.ceil(total / pageSize) + 1) &#123;</span><br><span class=\"line\">                //         fetchMore(&#123;</span><br><span class=\"line\">                //             variables: &#123;</span><br><span class=\"line\">                //                 filter: &#123;&#125;,</span><br><span class=\"line\">                //                 pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                //                 roleId,</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //             updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123;</span><br><span class=\"line\">                //                 // console.log(&#x27;previousResult&#x27;, previousResult, fetchMoreResult)</span><br><span class=\"line\">                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes</span><br><span class=\"line\">                //                 for (let node of nodes) &#123;</span><br><span class=\"line\">                //                     resultContent +=</span><br><span class=\"line\">                //                         node[&#x27;A&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                //                         &#x27;\\n&#x27;</span><br><span class=\"line\">                //                 &#125;</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //         &#125;)</span><br><span class=\"line\">                //         current++</span><br><span class=\"line\">                //     &#125; else &#123;</span><br><span class=\"line\">                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示</span><br><span class=\"line\">                //         const fileDateLines = resultContent.split(&#x27;\\n&#x27;).length - 1</span><br><span class=\"line\">                //         if (fileDateLines === total + 1) &#123;</span><br><span class=\"line\">                //             transferContent(resultContent)</span><br><span class=\"line\">                //         &#125; else &#123;</span><br><span class=\"line\">                //             message.warning(&#x27;数据量较大，导出数据出错，请联系管理员&#x27;)</span><br><span class=\"line\">                //         &#125;</span><br><span class=\"line\">                //         clearInterval(timer)</span><br><span class=\"line\">                //     &#125;</span><br><span class=\"line\">                // &#125;, 500)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前端下载文件有两种方式：\"><a href=\"#前端下载文件有两种方式：\" class=\"headerlink\" title=\"前端下载文件有两种方式：\"></a>前端下载文件有两种方式：</h3><p>1、通过后端返回的url，前端通过window.open(url);<br>2、后端返回的是二进制流，通过a标签实现下载。</p>\n<h5 id=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"><a href=\"#方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\" class=\"headerlink\" title=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"></a>方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。</h5><h5 id=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"><a href=\"#方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\" class=\"headerlink\" title=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"></a>方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">      method: &#x27;post&#x27;,</span><br><span class=\"line\">      url: &#x27;/api/trust/auditDownload&#x27;, //此处放hobber的内部的url</span><br><span class=\"line\">      data: params,</span><br><span class=\"line\">      responseType: &#x27;arraybuffer&#x27;, // 需要制定返回的类型，否则下载的文件会乱码</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">      // 假设 data 是返回来的二进制数据</span><br><span class=\"line\">      const data = res.data;</span><br><span class=\"line\">      const url = window.URL.createObjectURL( // type指定下载的文件的格式</span><br><span class=\"line\">        new Blob([data], &#123;</span><br><span class=\"line\">          type:</span><br><span class=\"line\">            &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">      const link = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">      link.style.display = &#x27;none&#x27;;</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.setAttribute(&#x27;download&#x27;, &#x27;excel.xlsx&#x27;); // 设置下载的文件名</span><br><span class=\"line\">      document.body.appendChild(link); </span><br><span class=\"line\">      link.click(); // 触发a标签</span><br><span class=\"line\">      document.body.removeChild(link); // 删除标签</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三、将二进制数据封装为文件读取FileReader对象\"><a href=\"#方法三、将二进制数据封装为文件读取FileReader对象\" class=\"headerlink\" title=\"方法三、将二进制数据封装为文件读取FileReader对象\"></a>方法三、将二进制数据封装为文件读取FileReader对象</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// utils.js</span><br><span class=\"line\">export const download = (res) =&gt; &#123;</span><br><span class=\"line\">  // 创建文件对象</span><br><span class=\"line\">  let reader = new FileReader()</span><br><span class=\"line\">  // 监听读取完毕</span><br><span class=\"line\">  reader.onloadend = function () &#123;</span><br><span class=\"line\">    // 返回base64位的文件内容</span><br><span class=\"line\">    let url = reader.result</span><br><span class=\"line\">    // 下载</span><br><span class=\"line\">    window.location.href = url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span><br><span class=\"line\">  reader.readAsDataURL(res)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。</p>\n<h5 id=\"方法四、使用插件file-saver\"><a href=\"#方法四、使用插件file-saver\" class=\"headerlink\" title=\"方法四、使用插件file-saver\"></a>方法四、使用插件file-saver</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save file-saver</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; saveAs &#125; from &#x27;file-saver&#x27;</span><br></pre></td></tr></table></figure>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制数据封装成blob对象</span><br><span class=\"line\">   const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  /**</span><br><span class=\"line\">    这里也可以使用File对象封装二进制数据</span><br><span class=\"line\">    const file = new File([res], filename, &#123;</span><br><span class=\"line\">      type: type</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  saveAs(blob,filename)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/eligrey/FileSaver.js\">插件源码</a></p>\n<h5 id=\"方法五、使用插件downloadjs\"><a href=\"#方法五、使用插件downloadjs\" class=\"headerlink\" title=\"方法五、使用插件downloadjs\"></a>方法五、使用插件downloadjs</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save downloadjs</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const download = require(&#x27;downloadjs&#x27;)</span><br></pre></td></tr></table></figure>\n<p>因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。</p>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制流转成blob对象</span><br><span class=\"line\">  const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  download(blob, filename, type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/rndme/download\">插件源码</a></p>\n<h5 id=\"二、发送请求，获取二进制流数据\"><a href=\"#二、发送请求，获取二进制流数据\" class=\"headerlink\" title=\"二、发送请求，获取二进制流数据\"></a>二、发送请求，获取二进制流数据</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;button @click=&#x27;handleDownload&#x27;&gt;下载&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 引入下载方法</span><br><span class=\"line\">import &#123;download&#125; from &#x27;utils&#x27;</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    async downloadFile () &#123;</span><br><span class=\"line\">      let res = await axios.get(</span><br><span class=\"line\">        url: &#x27;xxxx/xxxx&#x27;,</span><br><span class=\"line\">        method: &#x27;GET&#x27;,</span><br><span class=\"line\">        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`</span><br><span class=\"line\">        responseType: &#x27;blob&#x27;,</span><br><span class=\"line\">        params: &#123;</span><br><span class=\"line\">          id: &#x27;xxxxxx&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      // 获取在response headers中返回的下载文件类型</span><br><span class=\"line\">      let type = JSON.parse(res.headers)[&#x27;content-type&#x27;]</span><br><span class=\"line\">      </span><br><span class=\"line\">      /*获取在response headers中返回的下载文件名</span><br><span class=\"line\">        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码</span><br><span class=\"line\">      */</span><br><span class=\"line\">      let fileName = decodeURIComponent(JSON.parse(res.headers)[&#x27;file-name&#x27;])</span><br><span class=\"line\">      // 调用封装好的下载函数</span><br><span class=\"line\">      download(res, type, fileName)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 点击下载按钮下载</span><br><span class=\"line\">    handleDownload() &#123;</span><br><span class=\"line\">      this.downloadFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过数据源拼接生产excel文件\"><a href=\"#通过数据源拼接生产excel文件\" class=\"headerlink\" title=\"通过数据源拼接生产excel文件\"></a>通过数据源拼接生产excel文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const outputExcel = () =&gt; &#123;</span><br><span class=\"line\">        let resultContent = &#x27;A, B, C, D\\n&#x27;</span><br><span class=\"line\">        let transferContent = resultContent =&gt; &#123;</span><br><span class=\"line\">            //根据数据 利用a标签模仿下载生成本地文件</span><br><span class=\"line\">            let date = moment(new Date()).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">            const blob = new Blob([&#x27;\\ufeff&#x27;, resultContent], &#123;</span><br><span class=\"line\">                type: &#x27;text/csv&#x27;, // application/x-xls text/csv</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            const objectURL = window.URL.createObjectURL(blob)</span><br><span class=\"line\">            const download = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            download.href = objectURL</span><br><span class=\"line\">            download.download = `$&#123;date&#125;_$&#123;&#x27;文件名&#x27;&#125;.$&#123;&#x27;csv&#x27;&#125;`</span><br><span class=\"line\">            download.click()</span><br><span class=\"line\">            message.success(&#x27;文件已下载&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let generateTxt = message =&gt; &#123;</span><br><span class=\"line\">            var element = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            element.setAttribute(&#x27;href&#x27;, &#x27;data:text/plain;charset=utf-8,&#x27; + encodeURIComponent(message))</span><br><span class=\"line\">            element.setAttribute(&#x27;download&#x27;, &#x27;文件名&#x27; + new Date().getTime())</span><br><span class=\"line\">            element.style.display = &#x27;none&#x27;</span><br><span class=\"line\">            document.body.appendChild(element)</span><br><span class=\"line\">            element.click()</span><br><span class=\"line\">            document.body.removeChild(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let current = 1,</span><br><span class=\"line\">            pageSize = 8000</span><br><span class=\"line\"></span><br><span class=\"line\">        Modal.confirm(&#123;</span><br><span class=\"line\">            title: &#x27;提示&#x27;,</span><br><span class=\"line\">            content: &#x27;确认导出全部信息吗？&#x27;,</span><br><span class=\"line\">            okText: &#x27;确认&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">                // 一次访问8000条数据的方案</span><br><span class=\"line\">                refetch(&#123;</span><br><span class=\"line\">                    filter: &#123;&#125;,</span><br><span class=\"line\">                    pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                    roleId,</span><br><span class=\"line\">                &#125;).then(values =&gt; &#123;</span><br><span class=\"line\">                    console.log(&#x27;values&#x27;, values)</span><br><span class=\"line\">                    const total = values.data.allRoleUsers.total</span><br><span class=\"line\">                    const nodes = values.data.allRoleUsers.nodes</span><br><span class=\"line\">                    if (total &gt; pageSize) &#123;</span><br><span class=\"line\">                        message.warning(&#x27;用户数量太多&#x27;)</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        for (let node of nodes) &#123;</span><br><span class=\"line\">                            let expireDate = moment(node[&#x27;expireDate&#x27;]).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">                            if (expireDate === &#x27;9999-12-31&#x27;) &#123;</span><br><span class=\"line\">                                expireDate = &#x27;永久有效&#x27;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            resultContent +=</span><br><span class=\"line\">                                node[&#x27;A&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                expireDate +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                                &#x27;\\n&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // transferContent(resultContent)</span><br><span class=\"line\">                        generateTxt(resultContent)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                // 轮询接口的方案</span><br><span class=\"line\">                // const timer = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                //     // console.log(&#x27;current&#x27;, current, Math.ceil(total / pageSize) + 1)</span><br><span class=\"line\">                //     if (current &lt; Math.ceil(total / pageSize) + 1) &#123;</span><br><span class=\"line\">                //         fetchMore(&#123;</span><br><span class=\"line\">                //             variables: &#123;</span><br><span class=\"line\">                //                 filter: &#123;&#125;,</span><br><span class=\"line\">                //                 pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                //                 roleId,</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //             updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123;</span><br><span class=\"line\">                //                 // console.log(&#x27;previousResult&#x27;, previousResult, fetchMoreResult)</span><br><span class=\"line\">                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes</span><br><span class=\"line\">                //                 for (let node of nodes) &#123;</span><br><span class=\"line\">                //                     resultContent +=</span><br><span class=\"line\">                //                         node[&#x27;A&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                //                         &#x27;\\n&#x27;</span><br><span class=\"line\">                //                 &#125;</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //         &#125;)</span><br><span class=\"line\">                //         current++</span><br><span class=\"line\">                //     &#125; else &#123;</span><br><span class=\"line\">                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示</span><br><span class=\"line\">                //         const fileDateLines = resultContent.split(&#x27;\\n&#x27;).length - 1</span><br><span class=\"line\">                //         if (fileDateLines === total + 1) &#123;</span><br><span class=\"line\">                //             transferContent(resultContent)</span><br><span class=\"line\">                //         &#125; else &#123;</span><br><span class=\"line\">                //             message.warning(&#x27;数据量较大，导出数据出错，请联系管理员&#x27;)</span><br><span class=\"line\">                //         &#125;</span><br><span class=\"line\">                //         clearInterval(timer)</span><br><span class=\"line\">                //     &#125;</span><br><span class=\"line\">                // &#125;, 500)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"每天一个新问题（永远保持怀疑）","date":"2022-05-22T14:49:29.000Z","_content":"1、\\<\\> 、\\<React.Fragment\\>与\\<div\\>。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。\n    \n######     答案：\n```jsx\n// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，<> 和 <React.Fragment>中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）\n    <Form.Item name=\"opterator\" label=\"操作人：\">\n                <div  onChange={e=>{\n                  console.log(\"gerd => \" ,e)\n                }}>\n                <>\n                <div onChange={e=>{\n                  console.log(e);\n                  e.stopPropagation(); //阻止冒泡后，获取不到值\n                }}>\n                  <input\n                    // style={{ width: '75%' }}\n                    placeholder=\"请输入操作人\"\n                  />\n                </div>\n              </>\n             </div>\n        </Form.Item>\n```\n    \n \n2、antd的select的默认属性值在form表单中不起作用，获取的是undefined\n    \n  ######     答案\n  >form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。\n>\n\n3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。\n    \n######     解答\n    \n>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: [...data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。\n>\n\n4、 当我们开发时，经常遇到antd中日期选择器的时间处理。\n    \n######     解答\n```js\n// 通过monent函数转化，当然，monent需要引入函数库；import monent from 'monent';\nstartDate = moment(value.findDate[0].format('YYYY-MM-DD HH:mm:ss'));// 转化为开始日期\nendDate = moment(value.findDate[1].format('YYYY-MM-DD HH:mm:ss'));// 转化为结束日期\n// 此处的x为datepicker的value值哟。\n日期=》时间戳： x.unix()\n时间戳=》日期：moment( new Date(x * 1000 ))\n```\n    \n5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。\n    \n###### 郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\n>1）、redux\n>2）、将状态放在上级组件中存储 \n>3）、放在sessionstorage或localstorage中存储\n>\n\n优缺点：redux可避免状态外漏\n    \n\n| 序号 | 方法 |优点  | 缺点 |\n| --- | --- | --- | --- |\n|1  | redux | 避免状态信息的泄漏 | 每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值 |\n| 2 |将状态放在上级组件中存储  |  通过组件的props传值，获取值时机可靠|  组件间耦合关系太深，开发繁琐 |\n| 3 |放在sessionstorage或localstorage中存储  |  存储值方便|当页面跳转时，无法有效的删除storage和在session中泄露状态信息  |\n|4|放在url中存储 |方便页面跳转获取参数  |  当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密|\n\n```\n6、<a href=\"#\"></a>标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。\n    <Prompt\n      when={this.state.submit} // sunmit为提交按钮状态 默认为false\n      message={location => {\n        if (this.state.submit) {\n          Modal.confirm({\n            icon: <ExclamationCircleOutlined />,\n            content: '暂未提交您所做的更改，是否提交',\n            okText: '继续加载',\n            cancelText: '取消',\n            onOk: () => {\n              this.setState({ submit: false }, () => {\n                this.props.history.push(`${location.pathname}`);\n              });\n            },\n            onCancel: () => {},\n          });\n          return false; // 返回false时，阻塞路由跳转\n        }\n        return true; // 返回true时，路由跳转\n      }}\n```\n7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！\n \n8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新\n######     解答\n        react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。\n 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。\n######         坑\n       当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。\n######         解答\n        通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）","source":"_posts/每天一个新问题（永远保持怀疑）.md","raw":"---\ntitle: 每天一个新问题（永远保持怀疑）\ndate: 2022-05-22 22:49:29\ntag: 持续更新（ing）\n---\n1、\\<\\> 、\\<React.Fragment\\>与\\<div\\>。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。\n    \n######     答案：\n```jsx\n// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，<> 和 <React.Fragment>中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）\n    <Form.Item name=\"opterator\" label=\"操作人：\">\n                <div  onChange={e=>{\n                  console.log(\"gerd => \" ,e)\n                }}>\n                <>\n                <div onChange={e=>{\n                  console.log(e);\n                  e.stopPropagation(); //阻止冒泡后，获取不到值\n                }}>\n                  <input\n                    // style={{ width: '75%' }}\n                    placeholder=\"请输入操作人\"\n                  />\n                </div>\n              </>\n             </div>\n        </Form.Item>\n```\n    \n \n2、antd的select的默认属性值在form表单中不起作用，获取的是undefined\n    \n  ######     答案\n  >form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。\n>\n\n3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。\n    \n######     解答\n    \n>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: [...data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。\n>\n\n4、 当我们开发时，经常遇到antd中日期选择器的时间处理。\n    \n######     解答\n```js\n// 通过monent函数转化，当然，monent需要引入函数库；import monent from 'monent';\nstartDate = moment(value.findDate[0].format('YYYY-MM-DD HH:mm:ss'));// 转化为开始日期\nendDate = moment(value.findDate[1].format('YYYY-MM-DD HH:mm:ss'));// 转化为结束日期\n// 此处的x为datepicker的value值哟。\n日期=》时间戳： x.unix()\n时间戳=》日期：moment( new Date(x * 1000 ))\n```\n    \n5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。\n    \n###### 郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\n>1）、redux\n>2）、将状态放在上级组件中存储 \n>3）、放在sessionstorage或localstorage中存储\n>\n\n优缺点：redux可避免状态外漏\n    \n\n| 序号 | 方法 |优点  | 缺点 |\n| --- | --- | --- | --- |\n|1  | redux | 避免状态信息的泄漏 | 每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值 |\n| 2 |将状态放在上级组件中存储  |  通过组件的props传值，获取值时机可靠|  组件间耦合关系太深，开发繁琐 |\n| 3 |放在sessionstorage或localstorage中存储  |  存储值方便|当页面跳转时，无法有效的删除storage和在session中泄露状态信息  |\n|4|放在url中存储 |方便页面跳转获取参数  |  当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密|\n\n```\n6、<a href=\"#\"></a>标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。\n    <Prompt\n      when={this.state.submit} // sunmit为提交按钮状态 默认为false\n      message={location => {\n        if (this.state.submit) {\n          Modal.confirm({\n            icon: <ExclamationCircleOutlined />,\n            content: '暂未提交您所做的更改，是否提交',\n            okText: '继续加载',\n            cancelText: '取消',\n            onOk: () => {\n              this.setState({ submit: false }, () => {\n                this.props.history.push(`${location.pathname}`);\n              });\n            },\n            onCancel: () => {},\n          });\n          return false; // 返回false时，阻塞路由跳转\n        }\n        return true; // 返回true时，路由跳转\n      }}\n```\n7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！\n \n8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新\n######     解答\n        react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。\n 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。\n######         坑\n       当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。\n######         解答\n        通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）","slug":"每天一个新问题（永远保持怀疑）","published":1,"updated":"2025-06-22T01:39:55.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc703iqr0006wvtk5uh4334b","content":"<p>1、&lt;&gt; 、&lt;React.Fragment&gt;与&lt;div&gt;。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。</p>\n<h6 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h6><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，&lt;&gt; 和 &lt;React.Fragment&gt;中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）</span></span><br><span class=\"line\">    &lt;<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span> name=<span class=\"string\">&quot;opterator&quot;</span> label=<span class=\"string\">&quot;操作人：&quot;</span>&gt;</span><br><span class=\"line\">                <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>  <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(&quot;gerd =&gt; &quot; ,e)</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(e);</span></span><br><span class=\"line\"><span class=\"language-xml\">                  e.stopPropagation(); //阻止冒泡后，获取不到值</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    // <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> &#x27;<span class=\"attr\">75</span>%&#x27; &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入操作人&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">        &lt;/<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>2、antd的select的默认属性值在form表单中不起作用，获取的是undefined</p>\n<h6 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h6><blockquote>\n<p>form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。</p>\n</blockquote>\n<p>3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。</p>\n<h6 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h6><blockquote>\n<p>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: […data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。</p>\n</blockquote>\n<p>4、 当我们开发时，经常遇到antd中日期选择器的时间处理。</p>\n<h6 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过monent函数转化，当然，monent需要引入函数库；import monent from &#x27;monent&#x27;;</span></span><br><span class=\"line\">startDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">0</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为开始日期</span></span><br><span class=\"line\">endDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">1</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为结束日期</span></span><br><span class=\"line\"><span class=\"comment\">// 此处的x为datepicker的value值哟。</span></span><br><span class=\"line\">日期=》时间戳： x.<span class=\"title function_\">unix</span>()</span><br><span class=\"line\">时间戳=》日期：<span class=\"title function_\">moment</span>( <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(x * <span class=\"number\">1000</span> ))</span><br></pre></td></tr></table></figure>\n<p>5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。</p>\n<h6 id=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"><a href=\"#郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\" class=\"headerlink\" title=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"></a>郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。</h6><blockquote>\n<p>1）、redux<br>2）、将状态放在上级组件中存储<br>3）、放在sessionstorage或localstorage中存储</p>\n</blockquote>\n<p>优缺点：redux可避免状态外漏</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>redux</td>\n<td>避免状态信息的泄漏</td>\n<td>每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将状态放在上级组件中存储</td>\n<td>通过组件的props传值，获取值时机可靠</td>\n<td>组件间耦合关系太深，开发繁琐</td>\n</tr>\n<tr>\n<td>3</td>\n<td>放在sessionstorage或localstorage中存储</td>\n<td>存储值方便</td>\n<td>当页面跳转时，无法有效的删除storage和在session中泄露状态信息</td>\n</tr>\n<tr>\n<td>4</td>\n<td>放在url中存储</td>\n<td>方便页面跳转获取参数</td>\n<td>当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6、&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。</span><br><span class=\"line\">    &lt;Prompt</span><br><span class=\"line\">      when=&#123;this.state.submit&#125; // sunmit为提交按钮状态 默认为false</span><br><span class=\"line\">      message=&#123;location =&gt; &#123;</span><br><span class=\"line\">        if (this.state.submit) &#123;</span><br><span class=\"line\">          Modal.confirm(&#123;</span><br><span class=\"line\">            icon: &lt;ExclamationCircleOutlined /&gt;,</span><br><span class=\"line\">            content: &#x27;暂未提交您所做的更改，是否提交&#x27;,</span><br><span class=\"line\">            okText: &#x27;继续加载&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">              this.setState(&#123; submit: false &#125;, () =&gt; &#123;</span><br><span class=\"line\">                this.props.history.push(`$&#123;location.pathname&#125;`);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onCancel: () =&gt; &#123;&#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          return false; // 返回false时，阻塞路由跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true; // 返回true时，路由跳转</span><br><span class=\"line\">      &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！</p>\n<p>8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新</p>\n<h6 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n</code></pre>\n<p> 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。<br> 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。</p>\n<h6 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h6><pre><code>   当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n</code></pre>\n<p>11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。</p>\n<h6 id=\"解答-3\"><a href=\"#解答-3\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>1、&lt;&gt; 、&lt;React.Fragment&gt;与&lt;div&gt;。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。</p>\n<h6 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h6><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，&lt;&gt; 和 &lt;React.Fragment&gt;中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）</span></span><br><span class=\"line\">    &lt;<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span> name=<span class=\"string\">&quot;opterator&quot;</span> label=<span class=\"string\">&quot;操作人：&quot;</span>&gt;</span><br><span class=\"line\">                <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>  <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(&quot;gerd =&gt; &quot; ,e)</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(e);</span></span><br><span class=\"line\"><span class=\"language-xml\">                  e.stopPropagation(); //阻止冒泡后，获取不到值</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    // <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> &#x27;<span class=\"attr\">75</span>%&#x27; &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入操作人&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">        &lt;/<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>2、antd的select的默认属性值在form表单中不起作用，获取的是undefined</p>\n<h6 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h6><blockquote>\n<p>form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。</p>\n</blockquote>\n<p>3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。</p>\n<h6 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h6><blockquote>\n<p>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: […data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。</p>\n</blockquote>\n<p>4、 当我们开发时，经常遇到antd中日期选择器的时间处理。</p>\n<h6 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过monent函数转化，当然，monent需要引入函数库；import monent from &#x27;monent&#x27;;</span></span><br><span class=\"line\">startDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">0</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为开始日期</span></span><br><span class=\"line\">endDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">1</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为结束日期</span></span><br><span class=\"line\"><span class=\"comment\">// 此处的x为datepicker的value值哟。</span></span><br><span class=\"line\">日期=》时间戳： x.<span class=\"title function_\">unix</span>()</span><br><span class=\"line\">时间戳=》日期：<span class=\"title function_\">moment</span>( <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(x * <span class=\"number\">1000</span> ))</span><br></pre></td></tr></table></figure>\n<p>5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。</p>\n<h6 id=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"><a href=\"#郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\" class=\"headerlink\" title=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"></a>郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。</h6><blockquote>\n<p>1）、redux<br>2）、将状态放在上级组件中存储<br>3）、放在sessionstorage或localstorage中存储</p>\n</blockquote>\n<p>优缺点：redux可避免状态外漏</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>redux</td>\n<td>避免状态信息的泄漏</td>\n<td>每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将状态放在上级组件中存储</td>\n<td>通过组件的props传值，获取值时机可靠</td>\n<td>组件间耦合关系太深，开发繁琐</td>\n</tr>\n<tr>\n<td>3</td>\n<td>放在sessionstorage或localstorage中存储</td>\n<td>存储值方便</td>\n<td>当页面跳转时，无法有效的删除storage和在session中泄露状态信息</td>\n</tr>\n<tr>\n<td>4</td>\n<td>放在url中存储</td>\n<td>方便页面跳转获取参数</td>\n<td>当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6、&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。</span><br><span class=\"line\">    &lt;Prompt</span><br><span class=\"line\">      when=&#123;this.state.submit&#125; // sunmit为提交按钮状态 默认为false</span><br><span class=\"line\">      message=&#123;location =&gt; &#123;</span><br><span class=\"line\">        if (this.state.submit) &#123;</span><br><span class=\"line\">          Modal.confirm(&#123;</span><br><span class=\"line\">            icon: &lt;ExclamationCircleOutlined /&gt;,</span><br><span class=\"line\">            content: &#x27;暂未提交您所做的更改，是否提交&#x27;,</span><br><span class=\"line\">            okText: &#x27;继续加载&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">              this.setState(&#123; submit: false &#125;, () =&gt; &#123;</span><br><span class=\"line\">                this.props.history.push(`$&#123;location.pathname&#125;`);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onCancel: () =&gt; &#123;&#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          return false; // 返回false时，阻塞路由跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true; // 返回true时，路由跳转</span><br><span class=\"line\">      &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！</p>\n<p>8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新</p>\n<h6 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n</code></pre>\n<p> 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。<br> 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。</p>\n<h6 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h6><pre><code>   当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n</code></pre>\n<p>11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。</p>\n<h6 id=\"解答-3\"><a href=\"#解答-3\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）\n</code></pre>\n"},{"title":"浏览器安全","date":"2022-05-24T01:12:51.000Z","_content":"# 浏览器安全\n\n## web网页安全\n\n### 同源策略\n\n- 协议、域名和端口都相同\n- 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的\n- 主要表现在 DOM、Web 数据和网络这三个层面\n- 跨域共享数据\n\n\t- cros\n\n- 跨文档共享消息\n\n\t- 操作dom\n\t- postMessage\n\n### CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\n\n### xss\n\n- 恶意代码注入攻击\n\n\t- 存储型攻击\n\n\t\t- 将恶意脚本发送给服务器，服务器存储在数据库中\n\n\t- 反射型攻击\n\n\t\t- 不存储，将恶意脚本由服务器再返回给浏览器\n\n\t- 基于 DOM 的 XSS 攻击\n\n\t\t- 在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据\n\n- 阻止策略\n\n\t- 原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。\n\t- 1、服务器对输入脚本进行过滤或转码\n\t- 2. 充分利用 CSP\n\n\t\t- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；\n\t\t- 禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；\n\t\t- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。\n\n\t- 3. 使用 HttpOnly 属性\n\n\t\t- 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。\n\t\t- httpOnly由响应头设置\n\n###  CSRF 攻击，\n\n- CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事\n\n\t- 1、自动发送get请求\n\t- 2、自动发送post请求\n\t- 3、引诱用户点击链接\n\t- 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n- 阻止攻击\n\n\t- 1. 充分利用好 Cookie 的 SameSite 属性\n\n\t\t- 在set-cookie时设置\n\t\t- strict\n\n\t\t\t- 完全禁止第三方站点请求带上cookie\n\n\t\t- lax\n\n\t\t\t- 运行get请求\n\n\t\t\t\t- post，img，iframe加载url时不允许的\n\n\t\t- none\n\n\t\t\t- 完全开放请求\n\n\t- 2. 验证请求的来源站点\n\n\t\t- Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。\n\t\t- Origin 和 Referer 的一个主要区别。\n\n\t\t\t- Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，\n\t\t\t- origin更优先\n\n\t- 3. CSRF Token\n\n\t\t- 有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息\n\t\t- 第三方站点没有对应的csrf token\n\n## 浏览器系统安全\n\n### 安全沙箱\n![安全沙箱](安全沙箱.png)\n\n- 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。\n- 浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。\n- 安全沙箱最小的保护单位是进程。\n\n![渲染进程与浏览器内核](渲染进程与浏览器内核.png) \n\n### 无法阻止xss，csrf的攻击\n\n## 浏览器网络安全\n\n![浏览器安全](浏览器安全.png)\n\n### https加解密\n\n- 对称加密\n\n\t- 对称加密是指加密和解密都使用的是相同的密钥。\n\n![对称加密](对称加密.png)\n\n- 非对称加密\n\n\t- 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加\n密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来\n解密。\n\n![非对称加密](非对称加密.png)\n\n\t- 缺点\n\n\t\t- 第一个是非对称加密的效率太低。\n\t\t- 第二个是无法保证服务器发送给浏览器的数据安全。\n\n- 对称加密和非对称加密搭配使用\n\n\t- 在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。\n\n![对称混合非对称加密](对称混合非对称加密.png)\n\n- 添加数字证书\n\n![数字证书](数字证书.png)\n\n\t- ca证书中包含公司信息，公钥，等。\n\t- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n\t\t- 证书验证\n\n\t\t\t- 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n\n","source":"_posts/浏览器安全.md","raw":"---\ntitle: 浏览器安全\ndate: 2022-05-24 09:12:51\ntags: 安全\n---\n# 浏览器安全\n\n## web网页安全\n\n### 同源策略\n\n- 协议、域名和端口都相同\n- 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的\n- 主要表现在 DOM、Web 数据和网络这三个层面\n- 跨域共享数据\n\n\t- cros\n\n- 跨文档共享消息\n\n\t- 操作dom\n\t- postMessage\n\n### CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\n\n### xss\n\n- 恶意代码注入攻击\n\n\t- 存储型攻击\n\n\t\t- 将恶意脚本发送给服务器，服务器存储在数据库中\n\n\t- 反射型攻击\n\n\t\t- 不存储，将恶意脚本由服务器再返回给浏览器\n\n\t- 基于 DOM 的 XSS 攻击\n\n\t\t- 在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据\n\n- 阻止策略\n\n\t- 原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。\n\t- 1、服务器对输入脚本进行过滤或转码\n\t- 2. 充分利用 CSP\n\n\t\t- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；\n\t\t- 禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；\n\t\t- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。\n\n\t- 3. 使用 HttpOnly 属性\n\n\t\t- 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。\n\t\t- httpOnly由响应头设置\n\n###  CSRF 攻击，\n\n- CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事\n\n\t- 1、自动发送get请求\n\t- 2、自动发送post请求\n\t- 3、引诱用户点击链接\n\t- 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n- 阻止攻击\n\n\t- 1. 充分利用好 Cookie 的 SameSite 属性\n\n\t\t- 在set-cookie时设置\n\t\t- strict\n\n\t\t\t- 完全禁止第三方站点请求带上cookie\n\n\t\t- lax\n\n\t\t\t- 运行get请求\n\n\t\t\t\t- post，img，iframe加载url时不允许的\n\n\t\t- none\n\n\t\t\t- 完全开放请求\n\n\t- 2. 验证请求的来源站点\n\n\t\t- Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。\n\t\t- Origin 和 Referer 的一个主要区别。\n\n\t\t\t- Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，\n\t\t\t- origin更优先\n\n\t- 3. CSRF Token\n\n\t\t- 有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息\n\t\t- 第三方站点没有对应的csrf token\n\n## 浏览器系统安全\n\n### 安全沙箱\n![安全沙箱](安全沙箱.png)\n\n- 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。\n- 浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。\n- 安全沙箱最小的保护单位是进程。\n\n![渲染进程与浏览器内核](渲染进程与浏览器内核.png) \n\n### 无法阻止xss，csrf的攻击\n\n## 浏览器网络安全\n\n![浏览器安全](浏览器安全.png)\n\n### https加解密\n\n- 对称加密\n\n\t- 对称加密是指加密和解密都使用的是相同的密钥。\n\n![对称加密](对称加密.png)\n\n- 非对称加密\n\n\t- 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加\n密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来\n解密。\n\n![非对称加密](非对称加密.png)\n\n\t- 缺点\n\n\t\t- 第一个是非对称加密的效率太低。\n\t\t- 第二个是无法保证服务器发送给浏览器的数据安全。\n\n- 对称加密和非对称加密搭配使用\n\n\t- 在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。\n\n![对称混合非对称加密](对称混合非对称加密.png)\n\n- 添加数字证书\n\n![数字证书](数字证书.png)\n\n\t- ca证书中包含公司信息，公钥，等。\n\t- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n\t\t- 证书验证\n\n\t\t\t- 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n\n","slug":"浏览器安全","published":1,"updated":"2025-06-22T01:39:55.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc703iqs000awvtk31ifguin","content":"<h1 id=\"浏览器安全\"><a href=\"#浏览器安全\" class=\"headerlink\" title=\"浏览器安全\"></a>浏览器安全</h1><h2 id=\"web网页安全\"><a href=\"#web网页安全\" class=\"headerlink\" title=\"web网页安全\"></a>web网页安全</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ul>\n<li><p>协议、域名和端口都相同</p>\n</li>\n<li><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</p>\n</li>\n<li><p>主要表现在 DOM、Web 数据和网络这三个层面</p>\n</li>\n<li><p>跨域共享数据</p>\n<ul>\n<li>cros</li>\n</ul>\n</li>\n<li><p>跨文档共享消息</p>\n<ul>\n<li>操作dom</li>\n<li>postMessage</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\"><a href=\"#CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\" class=\"headerlink\" title=\"CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\"></a>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</h3><h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><ul>\n<li><p>恶意代码注入攻击</p>\n<ul>\n<li><p>存储型攻击</p>\n<ul>\n<li>将恶意脚本发送给服务器，服务器存储在数据库中</li>\n</ul>\n</li>\n<li><p>反射型攻击</p>\n<ul>\n<li>不存储，将恶意脚本由服务器再返回给浏览器</li>\n</ul>\n</li>\n<li><p>基于 DOM 的 XSS 攻击</p>\n<ul>\n<li>在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>阻止策略</p>\n<ul>\n<li><p>原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n</li>\n<li><p>1、服务器对输入脚本进行过滤或转码</p>\n</li>\n<li><ol start=\"2\">\n<li>充分利用 CSP</li>\n</ol>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>使用 HttpOnly 属性</li>\n</ol>\n<ul>\n<li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li>\n<li>httpOnly由响应头设置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSRF-攻击，\"><a href=\"#CSRF-攻击，\" class=\"headerlink\" title=\"CSRF 攻击，\"></a>CSRF 攻击，</h3><ul>\n<li><p>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<ul>\n<li>1、自动发送get请求</li>\n<li>2、自动发送post请求</li>\n<li>3、引诱用户点击链接</li>\n<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</li>\n</ul>\n</li>\n<li><p>阻止攻击</p>\n<ul>\n<li><ol>\n<li>充分利用好 Cookie 的 SameSite 属性</li>\n</ol>\n<ul>\n<li><p>在set-cookie时设置</p>\n</li>\n<li><p>strict</p>\n<ul>\n<li>完全禁止第三方站点请求带上cookie</li>\n</ul>\n</li>\n<li><p>lax</p>\n<ul>\n<li><p>运行get请求</p>\n<ul>\n<li>post，img，iframe加载url时不允许的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>none</p>\n<ul>\n<li>完全开放请求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>验证请求的来源站点</li>\n</ol>\n<ul>\n<li><p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。</p>\n</li>\n<li><p>Origin 和 Referer 的一个主要区别。</p>\n<ul>\n<li>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，</li>\n<li>origin更优先</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>CSRF Token</li>\n</ol>\n<ul>\n<li>有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息</li>\n<li>第三方站点没有对应的csrf token</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浏览器系统安全\"><a href=\"#浏览器系统安全\" class=\"headerlink\" title=\"浏览器系统安全\"></a>浏览器系统安全</h2><h3 id=\"安全沙箱\"><a href=\"#安全沙箱\" class=\"headerlink\" title=\"安全沙箱\"></a>安全沙箱</h3><p><img src=\"%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1.png\" alt=\"安全沙箱\"></p>\n<ul>\n<li>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>\n<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>\n<li>安全沙箱最小的保护单位是进程。</li>\n</ul>\n<p><img src=\"%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png\" alt=\"渲染进程与浏览器内核\"> </p>\n<h3 id=\"无法阻止xss，csrf的攻击\"><a href=\"#无法阻止xss，csrf的攻击\" class=\"headerlink\" title=\"无法阻止xss，csrf的攻击\"></a>无法阻止xss，csrf的攻击</h3><h2 id=\"浏览器网络安全\"><a href=\"#浏览器网络安全\" class=\"headerlink\" title=\"浏览器网络安全\"></a>浏览器网络安全</h2><p><img src=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.png\" alt=\"浏览器安全\"></p>\n<h3 id=\"https加解密\"><a href=\"#https加解密\" class=\"headerlink\" title=\"https加解密\"></a>https加解密</h3><ul>\n<li><p>对称加密</p>\n<ul>\n<li>对称加密是指加密和解密都使用的是相同的密钥。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称加密\"></p>\n<ul>\n<li><p>非对称加密</p>\n<ul>\n<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加<br>密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来<br>解密。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"非对称加密\"></p>\n<pre><code>- 缺点\n\n    - 第一个是非对称加密的效率太低。\n    - 第二个是无法保证服务器发送给浏览器的数据安全。\n</code></pre>\n<ul>\n<li><p>对称加密和非对称加密搭配使用</p>\n<ul>\n<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称混合非对称加密\"></p>\n<ul>\n<li>添加数字证书</li>\n</ul>\n<p><img src=\"%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png\" alt=\"数字证书\"></p>\n<pre><code>- ca证书中包含公司信息，公钥，等。\n- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n    - 证书验证\n\n        - 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器安全\"><a href=\"#浏览器安全\" class=\"headerlink\" title=\"浏览器安全\"></a>浏览器安全</h1><h2 id=\"web网页安全\"><a href=\"#web网页安全\" class=\"headerlink\" title=\"web网页安全\"></a>web网页安全</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ul>\n<li><p>协议、域名和端口都相同</p>\n</li>\n<li><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</p>\n</li>\n<li><p>主要表现在 DOM、Web 数据和网络这三个层面</p>\n</li>\n<li><p>跨域共享数据</p>\n<ul>\n<li>cros</li>\n</ul>\n</li>\n<li><p>跨文档共享消息</p>\n<ul>\n<li>操作dom</li>\n<li>postMessage</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\"><a href=\"#CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\" class=\"headerlink\" title=\"CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\"></a>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</h3><h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><ul>\n<li><p>恶意代码注入攻击</p>\n<ul>\n<li><p>存储型攻击</p>\n<ul>\n<li>将恶意脚本发送给服务器，服务器存储在数据库中</li>\n</ul>\n</li>\n<li><p>反射型攻击</p>\n<ul>\n<li>不存储，将恶意脚本由服务器再返回给浏览器</li>\n</ul>\n</li>\n<li><p>基于 DOM 的 XSS 攻击</p>\n<ul>\n<li>在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>阻止策略</p>\n<ul>\n<li><p>原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n</li>\n<li><p>1、服务器对输入脚本进行过滤或转码</p>\n</li>\n<li><ol start=\"2\">\n<li>充分利用 CSP</li>\n</ol>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>使用 HttpOnly 属性</li>\n</ol>\n<ul>\n<li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li>\n<li>httpOnly由响应头设置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSRF-攻击，\"><a href=\"#CSRF-攻击，\" class=\"headerlink\" title=\"CSRF 攻击，\"></a>CSRF 攻击，</h3><ul>\n<li><p>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<ul>\n<li>1、自动发送get请求</li>\n<li>2、自动发送post请求</li>\n<li>3、引诱用户点击链接</li>\n<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</li>\n</ul>\n</li>\n<li><p>阻止攻击</p>\n<ul>\n<li><ol>\n<li>充分利用好 Cookie 的 SameSite 属性</li>\n</ol>\n<ul>\n<li><p>在set-cookie时设置</p>\n</li>\n<li><p>strict</p>\n<ul>\n<li>完全禁止第三方站点请求带上cookie</li>\n</ul>\n</li>\n<li><p>lax</p>\n<ul>\n<li><p>运行get请求</p>\n<ul>\n<li>post，img，iframe加载url时不允许的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>none</p>\n<ul>\n<li>完全开放请求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>验证请求的来源站点</li>\n</ol>\n<ul>\n<li><p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。</p>\n</li>\n<li><p>Origin 和 Referer 的一个主要区别。</p>\n<ul>\n<li>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，</li>\n<li>origin更优先</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>CSRF Token</li>\n</ol>\n<ul>\n<li>有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息</li>\n<li>第三方站点没有对应的csrf token</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浏览器系统安全\"><a href=\"#浏览器系统安全\" class=\"headerlink\" title=\"浏览器系统安全\"></a>浏览器系统安全</h2><h3 id=\"安全沙箱\"><a href=\"#安全沙箱\" class=\"headerlink\" title=\"安全沙箱\"></a>安全沙箱</h3><p><img src=\"%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1.png\" alt=\"安全沙箱\"></p>\n<ul>\n<li>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>\n<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>\n<li>安全沙箱最小的保护单位是进程。</li>\n</ul>\n<p><img src=\"%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png\" alt=\"渲染进程与浏览器内核\"> </p>\n<h3 id=\"无法阻止xss，csrf的攻击\"><a href=\"#无法阻止xss，csrf的攻击\" class=\"headerlink\" title=\"无法阻止xss，csrf的攻击\"></a>无法阻止xss，csrf的攻击</h3><h2 id=\"浏览器网络安全\"><a href=\"#浏览器网络安全\" class=\"headerlink\" title=\"浏览器网络安全\"></a>浏览器网络安全</h2><p><img src=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.png\" alt=\"浏览器安全\"></p>\n<h3 id=\"https加解密\"><a href=\"#https加解密\" class=\"headerlink\" title=\"https加解密\"></a>https加解密</h3><ul>\n<li><p>对称加密</p>\n<ul>\n<li>对称加密是指加密和解密都使用的是相同的密钥。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称加密\"></p>\n<ul>\n<li><p>非对称加密</p>\n<ul>\n<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加<br>密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来<br>解密。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"非对称加密\"></p>\n<pre><code>- 缺点\n\n    - 第一个是非对称加密的效率太低。\n    - 第二个是无法保证服务器发送给浏览器的数据安全。\n</code></pre>\n<ul>\n<li><p>对称加密和非对称加密搭配使用</p>\n<ul>\n<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称混合非对称加密\"></p>\n<ul>\n<li>添加数字证书</li>\n</ul>\n<p><img src=\"%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png\" alt=\"数字证书\"></p>\n<pre><code>- ca证书中包含公司信息，公钥，等。\n- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n    - 证书验证\n\n        - 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmc703iqj0000wvtk5whbhk3u","category_id":"cmc703iqn0002wvtkdcjga9kd","_id":"cmc703iqt000bwvtk7vxk5p64"},{"post_id":"cmc703iqp0004wvtk27390ltq","category_id":"cmc703iqr0007wvtkbl5th6is","_id":"cmc703iqu000fwvtk5bd70j6r"},{"post_id":"cmc703iqq0005wvtkbaadd4si","category_id":"cmc703iqt000cwvtk75a39sp0","_id":"cmc703iqv000iwvtk49nqg5tu"}],"PostTag":[{"post_id":"cmc703iqj0000wvtk5whbhk3u","tag_id":"cmc703iqp0003wvtk8pj0b4vo","_id":"cmc703iqs0009wvtk3p52d7sc"},{"post_id":"cmc703iqm0001wvtkgiwf9yy9","tag_id":"cmc703iqs0008wvtk7gr51p2r","_id":"cmc703iqu000ewvtkcxci2j3i"},{"post_id":"cmc703iqp0004wvtk27390ltq","tag_id":"cmc703iqt000dwvtk8fkqen55","_id":"cmc703iqv000hwvtk9pu3267b"},{"post_id":"cmc703iqq0005wvtkbaadd4si","tag_id":"cmc703iqu000gwvtk2488e8n9","_id":"cmc703iqv000kwvtkhcrhhzac"},{"post_id":"cmc703iqr0006wvtk5uh4334b","tag_id":"cmc703iqs0008wvtk7gr51p2r","_id":"cmc703iqw000mwvtkgue53zd6"},{"post_id":"cmc703iqs000awvtk31ifguin","tag_id":"cmc703iqw000lwvtkhgnsfiq1","_id":"cmc703iqw000nwvtkbqkza9qt"}],"Tag":[{"name":"git javascript","_id":"cmc703iqp0003wvtk8pj0b4vo"},{"name":"持续更新（ing）","_id":"cmc703iqs0008wvtk7gr51p2r"},{"name":"后端接口","_id":"cmc703iqt000dwvtk8fkqen55"},{"name":"前端调接口下载","_id":"cmc703iqu000gwvtk2488e8n9"},{"name":"安全","_id":"cmc703iqw000lwvtkhgnsfiq1"}]}}