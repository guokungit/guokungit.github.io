{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/git.md","hash":"8863f35072c11fc292bb8ccc5b3a0777978c3f47","modified":1750556395183},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1750556395185},{"_id":"source/_posts/graphql看懂这篇直接开发.md","hash":"f13772a9b40eb22a37b7280063f81312806c48b7","modified":1750556395184},{"_id":"source/_posts/react前端下载后端返回的文件方法（url、二进制流）.md","hash":"7a040873d9deccfbdb23e516ceceae03bda11f15","modified":1750556395185},{"_id":"source/_posts/浏览器安全.md","hash":"9ee43ca6fe462c22eaf2d0f1f66028513196eea6","modified":1750556395198},{"_id":"source/_posts/每天一个新问题（永远保持怀疑）.md","hash":"1766635d2271b5bc31a4fc42901a1390d881a546","modified":1750556395187},{"_id":"source/_posts/检测后端接口常见方法.md","hash":"ebf4157039164a38ff35163948b0b05affcca527","modified":1750556395186},{"_id":"themes/3-hexo/.DS_Store","hash":"9ab12139365896d15d7002d2dbf5640ed19bdff6","modified":1750560850104},{"_id":"themes/3-hexo/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1750560850108},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1750560850108},{"_id":"themes/3-hexo/_config.yml","hash":"2cd9112a9dad660f78a2d3362aca1670323b39f4","modified":1750560850110},{"_id":"themes/3-hexo/README.md","hash":"d3b65547645e6cb494409969fe93bc824450b888","modified":1750560850109},{"_id":"themes/3-hexo/languages/en.yml","hash":"85fb1d7f8b704febedc247aeda19bc3c30bbc088","modified":1750560850112},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"c907bf3b8ef0b89bcd3ab90836e6f834518d36ba","modified":1750560850113},{"_id":"themes/3-hexo/layout/index.ejs","hash":"27ea3dac053d501b79bbef5117b4f3aff063d8cd","modified":1750560850140},{"_id":"themes/3-hexo/layout/indexs.md","hash":"b5f63a5da22505bd4bf09d45233ca1bf85bf390c","modified":1750560850141},{"_id":"themes/3-hexo/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0e662956cbfcaf6c1666e5c30a1fe03461de685e","modified":1750560850107},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"e0ca22b2c49d5d0b0e1e64170356a523cd8a51bf","modified":1750560850115},{"_id":"themes/3-hexo/layout/post.ejs","hash":"955cfffb5605099de53eb5bd5306975122d69f33","modified":1750560850142},{"_id":"themes/3-hexo/source/.DS_Store","hash":"7e1e04eb64d70d9be72d471c8f48f2442c4c92d0","modified":1750560850146},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"0ebb17d001cb7bb7606c616c380049a2e7124496","modified":1750560850116},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1750560850117},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"bc94eee27701b67d238f328737b578e8270989eb","modified":1750560850127},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"f66939a8c9d5258948b47842b8b4495e6ec45988","modified":1750560850126},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"bf7723eac5b36dc99a3c97f5bb219ddd85cab8e4","modified":1750560850131},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"d11092791e5c140ff81f2aefa0d1b051f403239d","modified":1750560850130},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"76768204853a8a5e030a96d605a247f9686cf994","modified":1750560850132},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1750560850133},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"3cf8ba0c6112dfa8089603b8df3e31f70a272715","modified":1750560850138},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1750560850139},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"a14cf10e8af1f7e83d6514c0a2912e14a0b8b0bd","modified":1750560850136},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"cbad17074f7a44520b4c7dad5a515d6aaf5e1e14","modified":1750560850135},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"82e715547344e7ba911d66b4ceacf7c011338bfc","modified":1750560850129},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"8a9e93f9cbe80763264018290da0b14b4bbe8ac5","modified":1750560850134},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"59a4abd36cc8ff2107f1fcb3c0fe48d0492c9030","modified":1750560850215},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1750560850188},{"_id":"themes/3-hexo/source/css/style.styl","hash":"7090b81f34e26172670c68da6a366ca186523779","modified":1750560850218},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1750560850223},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1750560850220},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1750560850227},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1750560850226},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1750560850221},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1750560850236},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1750560850244},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1750560850242},{"_id":"themes/3-hexo/source/js/script.js","hash":"e369c9098c3448fb5c144d904154b7e15ca28f67","modified":1750560850239},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1750560850238},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1750560850120},{"_id":"themes/3-hexo/layout/_partial/comments/giscus.ejs","hash":"941e7598a76f64fb4c5048c328a0237d05ca1abc","modified":1750560850121},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1750560850123},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1750560850122},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"e820aa16b5ed4e024616b5e2d424925820d43e56","modified":1750560850124},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"be91620693ca62e0ca72ee26e7712eeac6a320e1","modified":1750560850125},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1750560850151},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1750560850119},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c68d6942ed62f9cce8a9042f5a59055a0ee5441c","modified":1750560850152},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"2a9b5ffb759be85545a89f6d1194579a800f51a5","modified":1750560850149},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1750560850150},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0143711c1221cb4e70a3db866754d79c8a81d253","modified":1750560850162},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"d35df7f5e68880d1f1ebec541b816f8257fd42cb","modified":1750560850163},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1750560850166},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1750560850168},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1750560850173},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"05dcaf21f281f8ce483562e66fc31bc0fe8a2171","modified":1750560850164},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"7c307156ab5ea971b2414c79712e2e5932053ccf","modified":1750560850170},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1750560850178},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1750560850176},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1750560850174},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1750560850182},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1750560850183},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1750560850181},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1750560850186},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1750560850190},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1750560850180},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1750560850198},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1750560850187},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1750560850201},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1750560850191},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1750560850203},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1750560850202},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1750560850204},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1750560850206},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1750560850205},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1750560850207},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1750560850210},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1750560850213},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1750560850208},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1750560850213},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1750560850211},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1750560850214},{"_id":"source/_posts/git/gitrebase.png","hash":"e3ac521c51beec9a85729e143d2a631e0ac55cba","modified":1750556395183},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1750560850229},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1750560850235},{"_id":"source/_posts/浏览器安全/非对称加密.png","hash":"726f42224e3b820bfbe4b47ebafebeb19167c2c6","modified":1750556395197},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"2e622dbafa2b408baa1ab32df40c46ef67af6f93","modified":1750560850222},{"_id":"source/_posts/浏览器安全/浏览器安全.png","hash":"aaa65f1b424822e96a61f3c10dd77c0aae002e57","modified":1750556395195},{"_id":"source/_posts/浏览器安全/渲染进程与浏览器内核.png","hash":"cb854a85ad39a93b2baaeae65eaa4bcc75b5fa17","modified":1750556395196},{"_id":"source/_posts/浏览器安全/对称加密.png","hash":"7577ee47393c6c5b4819b4df501846f09490d33d","modified":1750556395191},{"_id":"source/_posts/浏览器安全/数字证书.png","hash":"a2c25869488db97bf2a1b5af4a880750d084b9de","modified":1750556395194},{"_id":"source/_posts/浏览器安全/对称混合非对称加密.png","hash":"7a69595fc45ec1f465ab334ee943d6fdc9678741","modified":1750556395192},{"_id":"source/_posts/浏览器安全/安全沙箱.png","hash":"839a7becbfe936c8b2a7ab1671f4db10b90dc23c","modified":1750556395189},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1750560850232},{"_id":"public/2025/06/22/hello-world/index.html","hash":"de340649238493bd4c8881989072da6b21e2e8f8","modified":1750561397338},{"_id":"public/2022/08/28/graphql看懂这篇直接开发/index.html","hash":"01d93b960fce3adeefda5c1fa85732e75e216e9c","modified":1750561397338},{"_id":"public/2022/05/24/浏览器安全/index.html","hash":"3f1a53ae9f24e98a5a7cf333dfcc26693622c37b","modified":1750561397338},{"_id":"public/2022/05/22/每天一个新问题（永远保持怀疑）/index.html","hash":"263e202d7b322337ad227939de743143ba54fd8f","modified":1750561397338},{"_id":"public/2022/05/22/react前端下载后端返回的文件方法（url、二进制流）/index.html","hash":"ac79f28141b3ab5153a2464693913730442bbad1","modified":1750561397338},{"_id":"public/2022/05/22/检测后端接口常见方法/index.html","hash":"3d7ab497c72c62c05d9613199eaa9b20511ff10c","modified":1750561397338},{"_id":"public/2022/05/22/git/index.html","hash":"2835fdd6b536efc1129f6a0c2afcb58d5352775e","modified":1750561397338},{"_id":"public/archives/2022/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/archives/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/archives/2025/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/archives/2025/06/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/archives/2022/05/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/archives/2022/08/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/categories/git/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/categories/下载/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/categories/后端接口/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/tags/git-javascript/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/tags/持续更新（ing）/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/tags/后端接口/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/tags/前端调接口下载/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/tags/安全/index.html","hash":"167ba1ab5d354bcd023032c08373a952a177a09a","modified":1750561397338},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1750561397338},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1750561397338},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1750561397338},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1750561397338},{"_id":"public/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1750561397338},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1750561397338},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1750561397338},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1750561397338},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1750561397338},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1750561397338},{"_id":"public/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1750561397338},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1750561397338},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1750561397338},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1750561397338},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1750561397338},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1750561397338},{"_id":"public/css/style.css","hash":"6df5cbffc43debacd3ac5660baf1d9457cbb2abd","modified":1750561397338},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1750561397338},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1750561397338},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1750561397338},{"_id":"public/js/script.js","hash":"e369c9098c3448fb5c144d904154b7e15ca28f67","modified":1750561397338},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1750561397338},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1750561397338},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1750561397338},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1750561397338},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1750561397338},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1750561397338},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1750561397338},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1750561397338},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1750561397338},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1750561397338},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1750561397338},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1750561397338},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1750561397338},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1750561397338},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1750561397338},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1750561397338},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1750561397338},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1750561397338},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1750561397338},{"_id":"public/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1750561397338},{"_id":"public/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1750561397338},{"_id":"public/img/avatar.jpg","hash":"2e622dbafa2b408baa1ab32df40c46ef67af6f93","modified":1750561397338}],"Category":[{"name":"git","_id":"cmc73233r00020xtk639w12ey"},{"name":"下载","_id":"cmc73233y00080xtkc8se5wrf"},{"name":"后端接口","_id":"cmc732340000f0xtkdc913c9s"}],"Data":[],"Page":[],"Post":[{"title":"实战中开发git","date":"2022-05-22T13:34:00.000Z","comments":1,"_content":"# 初始化仓库\n\ngit init\n\n## 克隆仓库\n\ngit clone git地址\n\n## 设置用户名和邮箱(--global 为全局参数，表明本地所有Git仓库都会使用这个配置)\n\ngit config --global user,name \"用户名\"\ngit config --global user.email \"用户邮箱\"\n\n## 链接远程仓库\n\ngit remote add origin git地址\n\n### 当修改密码后需要git push 时报http denied错误时\n输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）\n或\ngit config --global http.emptyAuth true \n### 当本地查看远程分支时\n###     ** git fetch origin。拉取远程分支列表\n\n|git branch  |  |  |\n| --- | --- | --- |\n| | 空 |查看本地分支|\n|  |-r  | 查看远程分支 |\n|  | -a  | 查看全部焚毁  |\n\n# 撤销git add . 的方法 -> git restore .\n\n## 撤销git commit -m \"注释\"，\n\n| git reset | --hard | 删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。 |\n| --- | --- | --- |\n|  | --mixed | 不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset --mixed HEAD^==git reset HEAD^ |\n|  | --sort | 不删除工作空间改动代码，不撤销git add ，撤销commit|\n| git commit  | --amend | 如果commit注释写错了，改一下注释 |\n\n## 推送仓库\n\n| git push | -u | 建立+推送远程分支 |\n| --- | --- | --- |\n|  | -f | 强制覆盖远程分支 |\n\n### 暂时存储工作区代码，（可以在分支间横跳代码）\n\n| git stash save \"save message\" | 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。 |\n| --- | --- |\n| git stash list | 查看stash了哪些存储 |\n| git stash show | 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} |\n| git stash show -p | 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p |\n| git stash apply | 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} |\n| git stash pop | 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1} |\n| git stash drop stash@{$num} | 丢弃stash@{$num}存储，从列表中删除这个存储 |\n| git stash clear | 删除所有缓存的stash |\n\n# 创建分支\n\ngit branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。\ngit checkout -b test; 创建并切换到test分支\n\n# 删除分支\n\ngit branch -d test：删除本地test分支\n\ngit branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。\n\ngit push origin --delete test 删除远程test分支\n\ngit push origin :test 删除远程test分支\n\n# 查看分支\n\n|git  | branch |空  |列出当前分支清单  |\n| --- | --- | --- | --- |\n|  |  | -r | 查看远程分支 |\n|  |  |-a  | 查看远程分支和本地分支 |\n|  |  | -v |查看各个分支最后一个提交信息  |\n|  |  |--merged  | 查看哪些分支已经合并入当前分支 |\n\n\n# 拉取分支\n\ngit fetch origin 同步远程服务器的数据到本地\n\ngit checkout -b test origin/test\\_remote 将远程分支test\\_remote拉取下来到本地test分支\n\ngit checkout test 将远程分支test拉取下来到本地test分支\n\ngit pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test\n\n## git merge的参数\nmerge的两个分支要有历史关联，没有的话需要添加git merge master --allow-unrelated-histories，参数。\n\n|git  |  merge |  | 合并分支到当前分支 |\n| --- | --- | --- | --- |\n|  |  | --ff  | 快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决 |\n|  |  |--ff-only  | 只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge  |\n|  |  |--no-ff   | 不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景） |\n|  |  | --squash | 压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来 |\n\n## git rebase的参数\n\n| git | rebase | 分布湿合并分支 |\n| --- | --- | --- |\n|-i HEAD~num  | 合并后num个commit记录 | p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。 |\n|-i [start] [end]  | 左开右闭 | start和end分别代码commit id |\n|-i [start] [end]  | onto [newbase] | 将部分分支复制到新commit上，实现中间一大段commit的删除 |\n通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)\n\n![截屏2021-12-01 18.38.28.png](gitrebase.png)\n在用d时可删除部分分支。s时前面得有pick，\n本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)\n### 复制部分分支\n\ngit rebase \\[startpoint\\] \\[endpoint\\] \\-\\-onto \\[branchName\\] （\\[startpoint\\] \\[endpoint\\]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）\n运行git rebase --continue命令继续变基。\n运行git rebase --abort命令回到rebase之前的状态。\n个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。\n\n# git commit 记录查询\n\n|  git | show | 空 |.查看最新的commit|\n| --- | --- | --- | --- |\n|  |  | commitId  | .查看指定commit hashID的所有修改：|\n|  |  | commitId fileName |.查看某次commit中具体某个文件的修改： |","source":"_posts/git.md","raw":"---\ntitle: 实战中开发git\ndate: 2022-05-22 21:34:00\ntags: git javascript\ncategories: git\ncomments: true\n---\n# 初始化仓库\n\ngit init\n\n## 克隆仓库\n\ngit clone git地址\n\n## 设置用户名和邮箱(--global 为全局参数，表明本地所有Git仓库都会使用这个配置)\n\ngit config --global user,name \"用户名\"\ngit config --global user.email \"用户邮箱\"\n\n## 链接远程仓库\n\ngit remote add origin git地址\n\n### 当修改密码后需要git push 时报http denied错误时\n输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）\n或\ngit config --global http.emptyAuth true \n### 当本地查看远程分支时\n###     ** git fetch origin。拉取远程分支列表\n\n|git branch  |  |  |\n| --- | --- | --- |\n| | 空 |查看本地分支|\n|  |-r  | 查看远程分支 |\n|  | -a  | 查看全部焚毁  |\n\n# 撤销git add . 的方法 -> git restore .\n\n## 撤销git commit -m \"注释\"，\n\n| git reset | --hard | 删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。 |\n| --- | --- | --- |\n|  | --mixed | 不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset --mixed HEAD^==git reset HEAD^ |\n|  | --sort | 不删除工作空间改动代码，不撤销git add ，撤销commit|\n| git commit  | --amend | 如果commit注释写错了，改一下注释 |\n\n## 推送仓库\n\n| git push | -u | 建立+推送远程分支 |\n| --- | --- | --- |\n|  | -f | 强制覆盖远程分支 |\n\n### 暂时存储工作区代码，（可以在分支间横跳代码）\n\n| git stash save \"save message\" | 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。 |\n| --- | --- |\n| git stash list | 查看stash了哪些存储 |\n| git stash show | 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} |\n| git stash show -p | 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p |\n| git stash apply | 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} |\n| git stash pop | 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1} |\n| git stash drop stash@{$num} | 丢弃stash@{$num}存储，从列表中删除这个存储 |\n| git stash clear | 删除所有缓存的stash |\n\n# 创建分支\n\ngit branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。\ngit checkout -b test; 创建并切换到test分支\n\n# 删除分支\n\ngit branch -d test：删除本地test分支\n\ngit branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。\n\ngit push origin --delete test 删除远程test分支\n\ngit push origin :test 删除远程test分支\n\n# 查看分支\n\n|git  | branch |空  |列出当前分支清单  |\n| --- | --- | --- | --- |\n|  |  | -r | 查看远程分支 |\n|  |  |-a  | 查看远程分支和本地分支 |\n|  |  | -v |查看各个分支最后一个提交信息  |\n|  |  |--merged  | 查看哪些分支已经合并入当前分支 |\n\n\n# 拉取分支\n\ngit fetch origin 同步远程服务器的数据到本地\n\ngit checkout -b test origin/test\\_remote 将远程分支test\\_remote拉取下来到本地test分支\n\ngit checkout test 将远程分支test拉取下来到本地test分支\n\ngit pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test\n\n## git merge的参数\nmerge的两个分支要有历史关联，没有的话需要添加git merge master --allow-unrelated-histories，参数。\n\n|git  |  merge |  | 合并分支到当前分支 |\n| --- | --- | --- | --- |\n|  |  | --ff  | 快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决 |\n|  |  |--ff-only  | 只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge  |\n|  |  |--no-ff   | 不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景） |\n|  |  | --squash | 压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来 |\n\n## git rebase的参数\n\n| git | rebase | 分布湿合并分支 |\n| --- | --- | --- |\n|-i HEAD~num  | 合并后num个commit记录 | p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。 |\n|-i [start] [end]  | 左开右闭 | start和end分别代码commit id |\n|-i [start] [end]  | onto [newbase] | 将部分分支复制到新commit上，实现中间一大段commit的删除 |\n通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)\n\n![截屏2021-12-01 18.38.28.png](gitrebase.png)\n在用d时可删除部分分支。s时前面得有pick，\n本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)\n### 复制部分分支\n\ngit rebase \\[startpoint\\] \\[endpoint\\] \\-\\-onto \\[branchName\\] （\\[startpoint\\] \\[endpoint\\]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）\n运行git rebase --continue命令继续变基。\n运行git rebase --abort命令回到rebase之前的状态。\n个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。\n\n# git commit 记录查询\n\n|  git | show | 空 |.查看最新的commit|\n| --- | --- | --- | --- |\n|  |  | commitId  | .查看指定commit hashID的所有修改：|\n|  |  | commitId fileName |.查看某次commit中具体某个文件的修改： |","slug":"git","published":1,"updated":"2025-06-22T01:39:55.183Z","layout":"post","photos":[],"link":"","_id":"cmc73233k00000xtk21au95ga","content":"<h1 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h1><p>git init</p>\n<h2 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库\"></a>克隆仓库</h2><p>git clone git地址</p>\n<h2 id=\"设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\"><a href=\"#设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\" class=\"headerlink\" title=\"设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)\"></a>设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)</h2><p>git config –global user,name “用户名”<br>git config –global user.email “用户邮箱”</p>\n<h2 id=\"链接远程仓库\"><a href=\"#链接远程仓库\" class=\"headerlink\" title=\"链接远程仓库\"></a>链接远程仓库</h2><p>git remote add origin git地址</p>\n<h3 id=\"当修改密码后需要git-push-时报http-denied错误时\"><a href=\"#当修改密码后需要git-push-时报http-denied错误时\" class=\"headerlink\" title=\"当修改密码后需要git push 时报http denied错误时\"></a>当修改密码后需要git push 时报http denied错误时</h3><p>输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）<br>或<br>git config –global http.emptyAuth true </p>\n<h3 id=\"当本地查看远程分支时\"><a href=\"#当本地查看远程分支时\" class=\"headerlink\" title=\"当本地查看远程分支时\"></a>当本地查看远程分支时</h3><h3 id=\"git-fetch-origin。拉取远程分支列表\"><a href=\"#git-fetch-origin。拉取远程分支列表\" class=\"headerlink\" title=\"** git fetch origin。拉取远程分支列表\"></a>** git fetch origin。拉取远程分支列表</h3><table>\n<thead>\n<tr>\n<th>git branch</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>空</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-a</td>\n<td>查看全部焚毁</td>\n</tr>\n</tbody></table>\n<h1 id=\"撤销git-add-的方法-gt-git-restore\"><a href=\"#撤销git-add-的方法-gt-git-restore\" class=\"headerlink\" title=\"撤销git add . 的方法 -&gt; git restore .\"></a>撤销git add . 的方法 -&gt; git restore .</h1><h2 id=\"撤销git-commit-m-“注释”，\"><a href=\"#撤销git-commit-m-“注释”，\" class=\"headerlink\" title=\"撤销git commit -m “注释”，\"></a>撤销git commit -m “注释”，</h2><table>\n<thead>\n<tr>\n<th>git reset</th>\n<th>–hard</th>\n<th>删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>–mixed</td>\n<td>不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset –mixed HEAD^==git reset HEAD^</td>\n</tr>\n<tr>\n<td></td>\n<td>–sort</td>\n<td>不删除工作空间改动代码，不撤销git add ，撤销commit</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>–amend</td>\n<td>如果commit注释写错了，改一下注释</td>\n</tr>\n</tbody></table>\n<h2 id=\"推送仓库\"><a href=\"#推送仓库\" class=\"headerlink\" title=\"推送仓库\"></a>推送仓库</h2><table>\n<thead>\n<tr>\n<th>git push</th>\n<th>-u</th>\n<th>建立+推送远程分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>-f</td>\n<td>强制覆盖远程分支</td>\n</tr>\n</tbody></table>\n<h3 id=\"暂时存储工作区代码，（可以在分支间横跳代码）\"><a href=\"#暂时存储工作区代码，（可以在分支间横跳代码）\" class=\"headerlink\" title=\"暂时存储工作区代码，（可以在分支间横跳代码）\"></a>暂时存储工作区代码，（可以在分支间横跳代码）</h3><table>\n<thead>\n<tr>\n<th>git stash save “save message”</th>\n<th>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>git stash list</td>\n<td>查看stash了哪些存储</td>\n</tr>\n<tr>\n<td>git stash show</td>\n<td>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</td>\n</tr>\n<tr>\n<td>git stash show -p</td>\n<td>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</td>\n</tr>\n<tr>\n<td>git stash apply</td>\n<td>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</td>\n</tr>\n<tr>\n<td>git stash pop</td>\n<td>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</td>\n</tr>\n<tr>\n<td>git stash drop stash@{$num}</td>\n<td>丢弃stash@{$num}存储，从列表中删除这个存储</td>\n</tr>\n<tr>\n<td>git stash clear</td>\n<td>删除所有缓存的stash</td>\n</tr>\n</tbody></table>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><p>git branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。<br>git checkout -b test; 创建并切换到test分支</p>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><p>git branch -d test：删除本地test分支</p>\n<p>git branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。</p>\n<p>git push origin –delete test 删除远程test分支</p>\n<p>git push origin :test 删除远程test分支</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>branch</th>\n<th>空</th>\n<th>列出当前分支清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-a</td>\n<td>查看远程分支和本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-v</td>\n<td>查看各个分支最后一个提交信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–merged</td>\n<td>查看哪些分支已经合并入当前分支</td>\n</tr>\n</tbody></table>\n<h1 id=\"拉取分支\"><a href=\"#拉取分支\" class=\"headerlink\" title=\"拉取分支\"></a>拉取分支</h1><p>git fetch origin 同步远程服务器的数据到本地</p>\n<p>git checkout -b test origin/test_remote 将远程分支test_remote拉取下来到本地test分支</p>\n<p>git checkout test 将远程分支test拉取下来到本地test分支</p>\n<p>git pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test</p>\n<h2 id=\"git-merge的参数\"><a href=\"#git-merge的参数\" class=\"headerlink\" title=\"git merge的参数\"></a>git merge的参数</h2><p>merge的两个分支要有历史关联，没有的话需要添加git merge master –allow-unrelated-histories，参数。</p>\n<table>\n<thead>\n<tr>\n<th>git</th>\n<th>merge</th>\n<th></th>\n<th>合并分支到当前分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>–ff</td>\n<td>快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–ff-only</td>\n<td>只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–no-ff</td>\n<td>不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–squash</td>\n<td>压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来</td>\n</tr>\n</tbody></table>\n<h2 id=\"git-rebase的参数\"><a href=\"#git-rebase的参数\" class=\"headerlink\" title=\"git rebase的参数\"></a>git rebase的参数</h2><table>\n<thead>\n<tr>\n<th>git</th>\n<th>rebase</th>\n<th>分布湿合并分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i HEAD~num</td>\n<td>合并后num个commit记录</td>\n<td>p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>左开右闭</td>\n<td>start和end分别代码commit id</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>onto [newbase]</td>\n<td>将部分分支复制到新commit上，实现中间一大段commit的删除</td>\n</tr>\n<tr>\n<td>通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"gitrebase.png\" alt=\"截屏2021-12-01 18.38.28.png\"><br>在用d时可删除部分分支。s时前面得有pick，<br>本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</p>\n<h3 id=\"复制部分分支\"><a href=\"#复制部分分支\" class=\"headerlink\" title=\"复制部分分支\"></a>复制部分分支</h3><p>git rebase [startpoint] [endpoint] --onto [branchName] （[startpoint] [endpoint]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）<br>运行git rebase –continue命令继续变基。<br>运行git rebase –abort命令回到rebase之前的状态。<br>个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。</p>\n<h1 id=\"git-commit-记录查询\"><a href=\"#git-commit-记录查询\" class=\"headerlink\" title=\"git commit 记录查询\"></a>git commit 记录查询</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>show</th>\n<th>空</th>\n<th>.查看最新的commit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>commitId</td>\n<td>.查看指定commit hashID的所有修改：</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>commitId fileName</td>\n<td>.查看某次commit中具体某个文件的修改：</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h1><p>git init</p>\n<h2 id=\"克隆仓库\"><a href=\"#克隆仓库\" class=\"headerlink\" title=\"克隆仓库\"></a>克隆仓库</h2><p>git clone git地址</p>\n<h2 id=\"设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\"><a href=\"#设置用户名和邮箱-–global-为全局参数，表明本地所有Git仓库都会使用这个配置\" class=\"headerlink\" title=\"设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)\"></a>设置用户名和邮箱(–global 为全局参数，表明本地所有Git仓库都会使用这个配置)</h2><p>git config –global user,name “用户名”<br>git config –global user.email “用户邮箱”</p>\n<h2 id=\"链接远程仓库\"><a href=\"#链接远程仓库\" class=\"headerlink\" title=\"链接远程仓库\"></a>链接远程仓库</h2><p>git remote add origin git地址</p>\n<h3 id=\"当修改密码后需要git-push-时报http-denied错误时\"><a href=\"#当修改密码后需要git-push-时报http-denied错误时\" class=\"headerlink\" title=\"当修改密码后需要git push 时报http denied错误时\"></a>当修改密码后需要git push 时报http denied错误时</h3><p>输入”git config –system –unset credential.helper”命令（重置远程端的用户名和密码）<br>或<br>git config –global http.emptyAuth true </p>\n<h3 id=\"当本地查看远程分支时\"><a href=\"#当本地查看远程分支时\" class=\"headerlink\" title=\"当本地查看远程分支时\"></a>当本地查看远程分支时</h3><h3 id=\"git-fetch-origin。拉取远程分支列表\"><a href=\"#git-fetch-origin。拉取远程分支列表\" class=\"headerlink\" title=\"** git fetch origin。拉取远程分支列表\"></a>** git fetch origin。拉取远程分支列表</h3><table>\n<thead>\n<tr>\n<th>git branch</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>空</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td>-a</td>\n<td>查看全部焚毁</td>\n</tr>\n</tbody></table>\n<h1 id=\"撤销git-add-的方法-gt-git-restore\"><a href=\"#撤销git-add-的方法-gt-git-restore\" class=\"headerlink\" title=\"撤销git add . 的方法 -&gt; git restore .\"></a>撤销git add . 的方法 -&gt; git restore .</h1><h2 id=\"撤销git-commit-m-“注释”，\"><a href=\"#撤销git-commit-m-“注释”，\" class=\"headerlink\" title=\"撤销git commit -m “注释”，\"></a>撤销git commit -m “注释”，</h2><table>\n<thead>\n<tr>\n<th>git reset</th>\n<th>–hard</th>\n<th>删除工作空间改动代码，撤销git add，撤销commit . 注意完成这个操作后，就恢复到了上一次的commit状态。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>–mixed</td>\n<td>不删除工作空间改动代码，撤销git add，撤销commit .为默认参数,git reset –mixed HEAD^==git reset HEAD^</td>\n</tr>\n<tr>\n<td></td>\n<td>–sort</td>\n<td>不删除工作空间改动代码，不撤销git add ，撤销commit</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>–amend</td>\n<td>如果commit注释写错了，改一下注释</td>\n</tr>\n</tbody></table>\n<h2 id=\"推送仓库\"><a href=\"#推送仓库\" class=\"headerlink\" title=\"推送仓库\"></a>推送仓库</h2><table>\n<thead>\n<tr>\n<th>git push</th>\n<th>-u</th>\n<th>建立+推送远程分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>-f</td>\n<td>强制覆盖远程分支</td>\n</tr>\n</tbody></table>\n<h3 id=\"暂时存储工作区代码，（可以在分支间横跳代码）\"><a href=\"#暂时存储工作区代码，（可以在分支间横跳代码）\" class=\"headerlink\" title=\"暂时存储工作区代码，（可以在分支间横跳代码）\"></a>暂时存储工作区代码，（可以在分支间横跳代码）</h3><table>\n<thead>\n<tr>\n<th>git stash save “save message”</th>\n<th>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>git stash list</td>\n<td>查看stash了哪些存储</td>\n</tr>\n<tr>\n<td>git stash show</td>\n<td>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</td>\n</tr>\n<tr>\n<td>git stash show -p</td>\n<td>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</td>\n</tr>\n<tr>\n<td>git stash apply</td>\n<td>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</td>\n</tr>\n<tr>\n<td>git stash pop</td>\n<td>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</td>\n</tr>\n<tr>\n<td>git stash drop stash@{$num}</td>\n<td>丢弃stash@{$num}存储，从列表中删除这个存储</td>\n</tr>\n<tr>\n<td>git stash clear</td>\n<td>删除所有缓存的stash</td>\n</tr>\n</tbody></table>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><p>git branch test: 基于当前commit创建test分支。.git/HEAD 文件中记录了当前分支名字。<br>git checkout -b test; 创建并切换到test分支</p>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><p>git branch -d test：删除本地test分支</p>\n<p>git branch -D test： test分支还没有合入当前分支，所以要用-D参数才能删掉。</p>\n<p>git push origin –delete test 删除远程test分支</p>\n<p>git push origin :test 删除远程test分支</p>\n<h1 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>branch</th>\n<th>空</th>\n<th>列出当前分支清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>-r</td>\n<td>查看远程分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-a</td>\n<td>查看远程分支和本地分支</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>-v</td>\n<td>查看各个分支最后一个提交信息</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–merged</td>\n<td>查看哪些分支已经合并入当前分支</td>\n</tr>\n</tbody></table>\n<h1 id=\"拉取分支\"><a href=\"#拉取分支\" class=\"headerlink\" title=\"拉取分支\"></a>拉取分支</h1><p>git fetch origin 同步远程服务器的数据到本地</p>\n<p>git checkout -b test origin/test_remote 将远程分支test_remote拉取下来到本地test分支</p>\n<p>git checkout test 将远程分支test拉取下来到本地test分支</p>\n<p>git pull test从远程分支test 中checkout下来的本地分支test成为跟踪分支，使用git pull或者git push就会操作到对应的远程分支test</p>\n<h2 id=\"git-merge的参数\"><a href=\"#git-merge的参数\" class=\"headerlink\" title=\"git merge的参数\"></a>git merge的参数</h2><p>merge的两个分支要有历史关联，没有的话需要添加git merge master –allow-unrelated-histories，参数。</p>\n<table>\n<thead>\n<tr>\n<th>git</th>\n<th>merge</th>\n<th></th>\n<th>合并分支到当前分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>–ff</td>\n<td>快速合并，这个是默认的参数。如果合并过程出现冲突，Git会显示出冲突并等待手动解决</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–ff-only</td>\n<td>只有能快速合并的情况才合并。如果合并过程出现冲突，Git会自动abort此次merge</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–no-ff</td>\n<td>不使用快速合并。会生成一次新的提交记录，这个记录只是标识在这里进行了一次merge操作（目前还没想到应用场景）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>–squash</td>\n<td>压缩合并。将待合并的分支的内容压缩成一个新的提交合并进来</td>\n</tr>\n</tbody></table>\n<h2 id=\"git-rebase的参数\"><a href=\"#git-rebase的参数\" class=\"headerlink\" title=\"git rebase的参数\"></a>git rebase的参数</h2><table>\n<thead>\n<tr>\n<th>git</th>\n<th>rebase</th>\n<th>分布湿合并分支</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i HEAD~num</td>\n<td>合并后num个commit记录</td>\n<td>p表示采用，s表示将当前commit合并到上一commit，d表示删除当前commit，。。。</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>左开右闭</td>\n<td>start和end分别代码commit id</td>\n</tr>\n<tr>\n<td>-i [start] [end]</td>\n<td>onto [newbase]</td>\n<td>将部分分支复制到新commit上，实现中间一大段commit的删除</td>\n</tr>\n<tr>\n<td>通过git rebase -i [start] [end] 或者 git rebase -i HEAD~num将本地的多次提交合并为一个，以简化提交历史。(左开右闭)</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><img src=\"gitrebase.png\" alt=\"截屏2021-12-01 18.38.28.png\"><br>在用d时可删除部分分支。s时前面得有pick，<br>本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</p>\n<h3 id=\"复制部分分支\"><a href=\"#复制部分分支\" class=\"headerlink\" title=\"复制部分分支\"></a>复制部分分支</h3><p>git rebase [startpoint] [endpoint] --onto [branchName] （[startpoint] [endpoint]指定的是一个前开后闭的区间，将该区间中的分支复制到另一个分支上）<br>运行git rebase –continue命令继续变基。<br>运行git rebase –abort命令回到rebase之前的状态。<br>个人见解，rebase就是操作本地的提交记录实现对commit的简化。git rebase branchname，在次合并分支，解决冲突，将冲突解决在开发分支上，避免主分支上出现脏分支记录。</p>\n<h1 id=\"git-commit-记录查询\"><a href=\"#git-commit-记录查询\" class=\"headerlink\" title=\"git commit 记录查询\"></a>git commit 记录查询</h1><table>\n<thead>\n<tr>\n<th>git</th>\n<th>show</th>\n<th>空</th>\n<th>.查看最新的commit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td>commitId</td>\n<td>.查看指定commit hashID的所有修改：</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>commitId fileName</td>\n<td>.查看某次commit中具体某个文件的修改：</td>\n</tr>\n</tbody></table>\n"},{"title":"graphql看懂这篇直接开发","date":"2022-08-28T09:44:15.000Z","_content":"# graphql的初尝\n\n## graphql\n\n### graphql在实战中踩坑\n\n- react-hoc(higherOrderComponent)\n\n\t- name\n\n\t\t- 改变返回值的名称\n\t\t- 定义mutate操作的名称\n\t\t- 此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。\n\n\t\t\t- export default graphName.HOC({name:'yourdefinedFunctionName',props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=>{return {yourdefinedFunctionName,refetch,variables})\n\n\t- props\n\n\t\t- 参数为请求返回来的数据，若没有name，默认为data\n\t\t- 返回值为传给子组件的props，merge方式\n\n\t\t\t- const {yourdefinedFunctionName} = props\n\n\t- options\n\n\t\t- 参数为父组件传进来的数据\n\t\t- 返回值为发起请求中的参数\n\t\t- 值为对象或函数\n\n\t\t\t- options: props=>{const {id} = props return {variables:{id}}\n\n\t- skip\n\n\t\t- export default graphql(gql`{ ... }`, {\n  skip: props => !!props.skip,\n})(MyComponent);\n\t\t- 值为布尔值或函数，\n\n\t\t\t- true\n\n\t\t\t\t- 跳过该graphql\n\n\t\t\t\t\t- 应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用\n\n\t\t\t- 函数，\n\n\t\t\t\t- 参数为父组件传入的props\n\t\t\t\t- 返回值为true/flase\n\n\t- withref\n\n\t\t- 通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。\n\n\t- alias\n\n\t\t- 配置高阶组件包装器的名称\n\t\t- 主要用于devtool来判断当前的组件名称，排错时用的\n\n- 理论\n\n\t- GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。\n\n\t- 按需整合返回的数据\n\n- 与restful的区别\n\n\t- 资源\n\n\t\t- 相同点\n\n\t\t\t- 都有资源这个概念，而且都能通过ID去获取资源。\n\t\t\t- 都可以通过HTTP GET方式来获取资源。\n\t\t\t- 都可以使用JSON作为响应格式。\n\n\t\t- 不同点\n\n\t\t\t- 在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关\n\t\t\t- 在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源\n\n\t- 路由\n\n\t\t- 相同点\n\n\t\t\t- REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。\n\t\t\t- 都能用不同的方式描述一个API请求到底是读操作还是写操作。\n\n\t\t- 不同点\n\n\t\t\t- GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。\n\t\t\t- 在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。\n\t\t\t- REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。\n\n\t- 解析器\n\n\t\t- 相同点\n\n\t\t\t- REST的端点与GraphQL查询字段都在服务端调起函数执行。\n\t\t\t- REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。\n\n\t\t- 不同点\n\n\t\t\t- 一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。\n\t\t\t- REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。\n\n- 截屏2022-06-30 11.54.48.png\n\n### 参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\n\n","source":"_posts/graphql看懂这篇直接开发.md","raw":"---\ntitle: graphql看懂这篇直接开发\ndate: 2022-08-28 17:44:15\ntags: 持续更新（ing）\n---\n# graphql的初尝\n\n## graphql\n\n### graphql在实战中踩坑\n\n- react-hoc(higherOrderComponent)\n\n\t- name\n\n\t\t- 改变返回值的名称\n\t\t- 定义mutate操作的名称\n\t\t- 此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。\n\n\t\t\t- export default graphName.HOC({name:'yourdefinedFunctionName',props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=>{return {yourdefinedFunctionName,refetch,variables})\n\n\t- props\n\n\t\t- 参数为请求返回来的数据，若没有name，默认为data\n\t\t- 返回值为传给子组件的props，merge方式\n\n\t\t\t- const {yourdefinedFunctionName} = props\n\n\t- options\n\n\t\t- 参数为父组件传进来的数据\n\t\t- 返回值为发起请求中的参数\n\t\t- 值为对象或函数\n\n\t\t\t- options: props=>{const {id} = props return {variables:{id}}\n\n\t- skip\n\n\t\t- export default graphql(gql`{ ... }`, {\n  skip: props => !!props.skip,\n})(MyComponent);\n\t\t- 值为布尔值或函数，\n\n\t\t\t- true\n\n\t\t\t\t- 跳过该graphql\n\n\t\t\t\t\t- 应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用\n\n\t\t\t- 函数，\n\n\t\t\t\t- 参数为父组件传入的props\n\t\t\t\t- 返回值为true/flase\n\n\t- withref\n\n\t\t- 通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。\n\n\t- alias\n\n\t\t- 配置高阶组件包装器的名称\n\t\t- 主要用于devtool来判断当前的组件名称，排错时用的\n\n- 理论\n\n\t- GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。\n\n\t- 按需整合返回的数据\n\n- 与restful的区别\n\n\t- 资源\n\n\t\t- 相同点\n\n\t\t\t- 都有资源这个概念，而且都能通过ID去获取资源。\n\t\t\t- 都可以通过HTTP GET方式来获取资源。\n\t\t\t- 都可以使用JSON作为响应格式。\n\n\t\t- 不同点\n\n\t\t\t- 在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关\n\t\t\t- 在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源\n\n\t- 路由\n\n\t\t- 相同点\n\n\t\t\t- REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。\n\t\t\t- 都能用不同的方式描述一个API请求到底是读操作还是写操作。\n\n\t\t- 不同点\n\n\t\t\t- GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。\n\t\t\t- 在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。\n\t\t\t- REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。\n\n\t- 解析器\n\n\t\t- 相同点\n\n\t\t\t- REST的端点与GraphQL查询字段都在服务端调起函数执行。\n\t\t\t- REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。\n\n\t\t- 不同点\n\n\t\t\t- 一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。\n\t\t\t- REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。\n\n- 截屏2022-06-30 11.54.48.png\n\n### 参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\n\n","slug":"graphql看懂这篇直接开发","published":1,"updated":"2025-06-22T01:39:55.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc73233o00010xtk5u8h1xkj","content":"<h1 id=\"graphql的初尝\"><a href=\"#graphql的初尝\" class=\"headerlink\" title=\"graphql的初尝\"></a>graphql的初尝</h1><h2 id=\"graphql\"><a href=\"#graphql\" class=\"headerlink\" title=\"graphql\"></a>graphql</h2><h3 id=\"graphql在实战中踩坑\"><a href=\"#graphql在实战中踩坑\" class=\"headerlink\" title=\"graphql在实战中踩坑\"></a>graphql在实战中踩坑</h3><ul>\n<li><p>react-hoc(higherOrderComponent)</p>\n<ul>\n<li><p>name</p>\n<ul>\n<li><p>改变返回值的名称</p>\n</li>\n<li><p>定义mutate操作的名称</p>\n</li>\n<li><p>此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。</p>\n<ul>\n<li>export default graphName.HOC({name:’yourdefinedFunctionName’,props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=&gt;{return {yourdefinedFunctionName,refetch,variables})</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>props</p>\n<ul>\n<li><p>参数为请求返回来的数据，若没有name，默认为data</p>\n</li>\n<li><p>返回值为传给子组件的props，merge方式</p>\n<ul>\n<li>const {yourdefinedFunctionName} = props</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>options</p>\n<ul>\n<li><p>参数为父组件传进来的数据</p>\n</li>\n<li><p>返回值为发起请求中的参数</p>\n</li>\n<li><p>值为对象或函数</p>\n<ul>\n<li>options: props=&gt;{const {id} = props return {variables:{id}}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>skip</p>\n<ul>\n<li><p>export default graphql(gql<code>&#123; ... &#125;</code>, {<br>skip: props =&gt; !!props.skip,<br>})(MyComponent);</p>\n</li>\n<li><p>值为布尔值或函数，</p>\n<ul>\n<li><p>true</p>\n<ul>\n<li><p>跳过该graphql</p>\n<ul>\n<li>应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>函数，</p>\n<ul>\n<li>参数为父组件传入的props</li>\n<li>返回值为true/flase</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>withref</p>\n<ul>\n<li>通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。</li>\n</ul>\n</li>\n<li><p>alias</p>\n<ul>\n<li>配置高阶组件包装器的名称</li>\n<li>主要用于devtool来判断当前的组件名称，排错时用的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>理论</p>\n<ul>\n<li><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。</p>\n</li>\n<li><p>按需整合返回的数据</p>\n</li>\n</ul>\n</li>\n<li><p>与restful的区别</p>\n<ul>\n<li><p>资源</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>都有资源这个概念，而且都能通过ID去获取资源。</li>\n<li>都可以通过HTTP GET方式来获取资源。</li>\n<li>都可以使用JSON作为响应格式。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关</li>\n<li>在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。</li>\n<li>都能用不同的方式描述一个API请求到底是读操作还是写操作。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。</li>\n<li>在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。</li>\n<li>REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解析器</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST的端点与GraphQL查询字段都在服务端调起函数执行。</li>\n<li>REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。</li>\n<li>REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>截屏2022-06-30 11.54.48.png</p>\n</li>\n</ul>\n<h3 id=\"参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\"><a href=\"#参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\" class=\"headerlink\" title=\"参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\"></a>参考网址：<a href=\"https://www.apollographql.com/docs/react/v2/api/react-hoc\">https://www.apollographql.com/docs/react/v2/api/react-hoc</a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"graphql的初尝\"><a href=\"#graphql的初尝\" class=\"headerlink\" title=\"graphql的初尝\"></a>graphql的初尝</h1><h2 id=\"graphql\"><a href=\"#graphql\" class=\"headerlink\" title=\"graphql\"></a>graphql</h2><h3 id=\"graphql在实战中踩坑\"><a href=\"#graphql在实战中踩坑\" class=\"headerlink\" title=\"graphql在实战中踩坑\"></a>graphql在实战中踩坑</h3><ul>\n<li><p>react-hoc(higherOrderComponent)</p>\n<ul>\n<li><p>name</p>\n<ul>\n<li><p>改变返回值的名称</p>\n</li>\n<li><p>定义mutate操作的名称</p>\n</li>\n<li><p>此属性允许您配置传递给组件的props的名称。默认情况下，如果您传入的 GraphQL 文档graphql()是一个查询，那么您的 prop 将被命名为data. 如果你传递一个突变，那么你的props将被命名mutate。当您尝试对同一组件使用多个查询或突变时，这些默认名称虽然适当，但会发生冲突。为避免冲突，您可以使用config.name为每个查询或变异 HOC 的 prop 提供一个新名称。</p>\n<ul>\n<li>export default graphName.HOC({name:’yourdefinedFunctionName’,props:(yourdefinedFunctionName:{yourdefinedFunctionName,refetch,variables})=&gt;{return {yourdefinedFunctionName,refetch,variables})</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>props</p>\n<ul>\n<li><p>参数为请求返回来的数据，若没有name，默认为data</p>\n</li>\n<li><p>返回值为传给子组件的props，merge方式</p>\n<ul>\n<li>const {yourdefinedFunctionName} = props</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>options</p>\n<ul>\n<li><p>参数为父组件传进来的数据</p>\n</li>\n<li><p>返回值为发起请求中的参数</p>\n</li>\n<li><p>值为对象或函数</p>\n<ul>\n<li>options: props=&gt;{const {id} = props return {variables:{id}}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>skip</p>\n<ul>\n<li><p>export default graphql(gql<code>&#123; ... &#125;</code>, {<br>skip: props =&gt; !!props.skip,<br>})(MyComponent);</p>\n</li>\n<li><p>值为布尔值或函数，</p>\n<ul>\n<li><p>true</p>\n<ul>\n<li><p>跳过该graphql</p>\n<ul>\n<li>应用场景，减少不必要的接口调用，比如，通过父组件传入的props属性值判断，第一次接口是否调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>函数，</p>\n<ul>\n<li>参数为父组件传入的props</li>\n<li>返回值为true/flase</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>withref</p>\n<ul>\n<li>通过设置config.withRef为 true，您将能够使用高阶 GraphQL 组件getWrappedInstance实例上可用的方法从高阶 GraphQL 组件中获取包装组件的实例。</li>\n</ul>\n</li>\n<li><p>alias</p>\n<ul>\n<li>配置高阶组件包装器的名称</li>\n<li>主要用于devtool来判断当前的组件名称，排错时用的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>理论</p>\n<ul>\n<li><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。GraphQL 最大的优势是查询图状数据。</p>\n</li>\n<li><p>按需整合返回的数据</p>\n</li>\n</ul>\n</li>\n<li><p>与restful的区别</p>\n<ul>\n<li><p>资源</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>都有资源这个概念，而且都能通过ID去获取资源。</li>\n<li>都可以通过HTTP GET方式来获取资源。</li>\n<li>都可以使用JSON作为响应格式。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>在REST中，你所访问的路径就是该资源的唯一标识（ID）；在GraphQL中，该标识与访问方式并不相关</li>\n<li>在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST API的URL端点列表与GraphQL的Query/Mutation中的字段类似，都表示数据的访问入口。</li>\n<li>都能用不同的方式描述一个API请求到底是读操作还是写操作。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>GraphQL让你可以通过一个资源入口访问到关联的其他资源，只要事先在schema中定义好资源之间的关系即可；而REST则提供了多个URL端点来获取相关的资源。</li>\n<li>在GraphQL中，Query类型可以在一个请求的根节点中被访问，除此以外它跟其他类型没有区别，比如你也可以对一个query中的字段添加参数。而在REST中，即使响应结果是嵌套关系，但在请求中并没有嵌套的概念。</li>\n<li>REST使用POST这样的HTTP方法名称来定义写操作，GraphQL则是查询结构中的关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解析器</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>REST的端点与GraphQL查询字段都在服务端调起函数执行。</li>\n<li>REST和GraphQL都使用框架和类库来进行一些通用的网络协议处理。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>一个REST请求对应一个路由处理器（Route Handler），而一个GraphQL的请求可以唤起多个解析器（Resolver）在一次响应中访问多种资源。</li>\n<li>REST需要你自己构建整个请求的响应，而GraphQL的请求响应是由查询方指定结构、并由GraphQL进行构建组装的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>截屏2022-06-30 11.54.48.png</p>\n</li>\n</ul>\n<h3 id=\"参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\"><a href=\"#参考网址：https-www-apollographql-com-docs-react-v2-api-react-hoc\" class=\"headerlink\" title=\"参考网址：https://www.apollographql.com/docs/react/v2/api/react-hoc\"></a>参考网址：<a href=\"https://www.apollographql.com/docs/react/v2/api/react-hoc\">https://www.apollographql.com/docs/react/v2/api/react-hoc</a></h3>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-06-22T01:36:03.503Z","updated":"2025-06-22T01:39:55.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc73233t00040xtk49z64x9w","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"react前端下载后端返回的文件方法（url、二进制流）","date":"2022-05-22T14:41:02.000Z","comments":1,"_content":"### 前端下载文件有两种方式：\n1、通过后端返回的url，前端通过window.open(url);\n2、后端返回的是二进制流，通过a标签实现下载。\n##### 方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\n##### 方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\n```\naxios({\n      method: 'post',\n      url: '/api/trust/auditDownload', //此处放hobber的内部的url\n      data: params,\n      responseType: 'arraybuffer', // 需要制定返回的类型，否则下载的文件会乱码\n    }).then(res => {\n      // 假设 data 是返回来的二进制数据\n      const data = res.data;\n      const url = window.URL.createObjectURL( // type指定下载的文件的格式\n        new Blob([data], {\n          type:\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        }),\n      );\n      const link = document.createElement('a');\n      link.style.display = 'none';\n      link.href = url;\n      link.setAttribute('download', 'excel.xlsx'); // 设置下载的文件名\n      document.body.appendChild(link); \n      link.click(); // 触发a标签\n      document.body.removeChild(link); // 删除标签\n    });\n```\n##### 方法三、将二进制数据封装为文件读取FileReader对象\n```\n// utils.js\nexport const download = (res) => {\n  // 创建文件对象\n  let reader = new FileReader()\n  // 监听读取完毕\n  reader.onloadend = function () {\n    // 返回base64位的文件内容\n    let url = reader.result\n    // 下载\n    window.location.href = url\n  }\n  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\n  reader.readAsDataURL(res)\n}\n```\n注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。\n\n##### 方法四、使用插件file-saver\n下载插件\n```\n npm install --save file-saver\n```\n引入插件\n```\n import { saveAs } from 'file-saver'\n```\n封装下载方法，使用插件\n```\n export const downloadFile = (res, type, filename) => {\n   // 将二进制数据封装成blob对象\n    const blob = new Blob([res], {\n     type: type\n   })\n   /**\n     这里也可以使用File对象封装二进制数据\n     const file = new File([res], filename, {\n       type: type\n     });\n   */\n   // 调用插件方法\n   saveAs(blob,filename)\n }\n```\n[插件源码](https://github.com/eligrey/FileSaver.js)\n##### 方法五、使用插件downloadjs\n下载插件\n```\n npm install --save downloadjs\n```\n引入插件\n```\n const download = require('downloadjs')\n```\n因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。\n\n封装下载方法，使用插件\n```\n  export const downloadFile = (res, type, filename) => {\n    // 将二进制流转成blob对象\n    const blob = new Blob([res], {\n      type: type\n    })\n    // 调用插件方法\n    download(blob, filename, type);\n  }\n\n```\n[插件源码](https://github.com/rndme/download)\n##### 二、发送请求，获取二进制流数据\n```\n// index.vue\n<template>\n  <div>\n    <button @click='handleDownload'>下载</button>\n  </div>\n</template>\n<script>\n// 引入下载方法\nimport {download} from 'utils'\nexport default{\n  methods: {\n    async downloadFile () {\n      let res = await axios.get(\n        url: 'xxxx/xxxx',\n        method: 'GET',\n        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`\n        responseType: 'blob',\n        params: {\n          id: 'xxxxxx'\n        }\n      )\n      // 获取在response headers中返回的下载文件类型\n      let type = JSON.parse(res.headers)['content-type']\n      \n      /*获取在response headers中返回的下载文件名\n        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码\n      */\n      let fileName = decodeURIComponent(JSON.parse(res.headers)['file-name'])\n      // 调用封装好的下载函数\n      download(res, type, fileName)\n    },\n    // 点击下载按钮下载\n    handleDownload() {\n      this.downloadFile()\n    }\n  }\n}\n</script>\n```\n##### 通过数据源拼接生产excel文件\n```\nconst outputExcel = () => {\n        let resultContent = 'A, B, C, D\\n'\n        let transferContent = resultContent => {\n            //根据数据 利用a标签模仿下载生成本地文件\n            let date = moment(new Date()).format('YYYY-MM-DD')\n            const blob = new Blob(['\\ufeff', resultContent], {\n                type: 'text/csv', // application/x-xls text/csv\n            })\n            const objectURL = window.URL.createObjectURL(blob)\n            const download = document.createElement('a')\n            download.href = objectURL\n            download.download = `${date}_${'文件名'}.${'csv'}`\n            download.click()\n            message.success('文件已下载')\n        }\n        let generateTxt = message => {\n            var element = document.createElement('a')\n            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(message))\n            element.setAttribute('download', '文件名' + new Date().getTime())\n            element.style.display = 'none'\n            document.body.appendChild(element)\n            element.click()\n            document.body.removeChild(element)\n        }\n        let current = 1,\n            pageSize = 8000\n\n        Modal.confirm({\n            title: '提示',\n            content: '确认导出全部信息吗？',\n            okText: '确认',\n            cancelText: '取消',\n            onOk: () => {\n                // 一次访问8000条数据的方案\n                refetch({\n                    filter: {},\n                    pager: { sort: '', current, pageSize },\n                    roleId,\n                }).then(values => {\n                    console.log('values', values)\n                    const total = values.data.allRoleUsers.total\n                    const nodes = values.data.allRoleUsers.nodes\n                    if (total > pageSize) {\n                        message.warning('用户数量太多')\n                    } else {\n                        for (let node of nodes) {\n                            let expireDate = moment(node['expireDate']).format('YYYY-MM-DD')\n                            if (expireDate === '9999-12-31') {\n                                expireDate = '永久有效'\n                            }\n                            resultContent +=\n                                node['A'] +\n                                ',' +\n                                node['B']['C'] +\n                                ',' +\n                                expireDate +\n                                ',' +\n                                moment(node['D']).format('YYYY-MM-DD') +\n                                '\\n'\n                        }\n                        // transferContent(resultContent)\n                        generateTxt(resultContent)\n                    }\n                })\n                // 轮询接口的方案\n                // const timer = setInterval(() => {\n                //     // console.log('current', current, Math.ceil(total / pageSize) + 1)\n                //     if (current < Math.ceil(total / pageSize) + 1) {\n                //         fetchMore({\n                //             variables: {\n                //                 filter: {},\n                //                 pager: { sort: '', current, pageSize },\n                //                 roleId,\n                //             },\n                //             updateQuery: (previousResult, { fetchMoreResult }) => {\n                //                 // console.log('previousResult', previousResult, fetchMoreResult)\n                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes\n                //                 for (let node of nodes) {\n                //                     resultContent +=\n                //                         node['A'] +\n                //                         ',' +\n                //                         node['B']['C'] +\n                //                         ',' +\n                //                         moment(node['D']).format('YYYY-MM-DD') +\n                //                         '\\n'\n                //                 }\n                //             },\n                //         })\n                //         current++\n                //     } else {\n                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示\n                //         const fileDateLines = resultContent.split('\\n').length - 1\n                //         if (fileDateLines === total + 1) {\n                //             transferContent(resultContent)\n                //         } else {\n                //             message.warning('数据量较大，导出数据出错，请联系管理员')\n                //         }\n                //         clearInterval(timer)\n                //     }\n                // }, 500)\n            },\n        })\n    }\n```","source":"_posts/react前端下载后端返回的文件方法（url、二进制流）.md","raw":"---\ntitle: react前端下载后端返回的文件方法（url、二进制流）\ndate: 2022-05-22 22:41:02\ntags: 前端调接口下载\ncategories: 下载\ncomments: true\n---\n### 前端下载文件有两种方式：\n1、通过后端返回的url，前端通过window.open(url);\n2、后端返回的是二进制流，通过a标签实现下载。\n##### 方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\n##### 方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\n```\naxios({\n      method: 'post',\n      url: '/api/trust/auditDownload', //此处放hobber的内部的url\n      data: params,\n      responseType: 'arraybuffer', // 需要制定返回的类型，否则下载的文件会乱码\n    }).then(res => {\n      // 假设 data 是返回来的二进制数据\n      const data = res.data;\n      const url = window.URL.createObjectURL( // type指定下载的文件的格式\n        new Blob([data], {\n          type:\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        }),\n      );\n      const link = document.createElement('a');\n      link.style.display = 'none';\n      link.href = url;\n      link.setAttribute('download', 'excel.xlsx'); // 设置下载的文件名\n      document.body.appendChild(link); \n      link.click(); // 触发a标签\n      document.body.removeChild(link); // 删除标签\n    });\n```\n##### 方法三、将二进制数据封装为文件读取FileReader对象\n```\n// utils.js\nexport const download = (res) => {\n  // 创建文件对象\n  let reader = new FileReader()\n  // 监听读取完毕\n  reader.onloadend = function () {\n    // 返回base64位的文件内容\n    let url = reader.result\n    // 下载\n    window.location.href = url\n  }\n  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。\n  reader.readAsDataURL(res)\n}\n```\n注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。\n\n##### 方法四、使用插件file-saver\n下载插件\n```\n npm install --save file-saver\n```\n引入插件\n```\n import { saveAs } from 'file-saver'\n```\n封装下载方法，使用插件\n```\n export const downloadFile = (res, type, filename) => {\n   // 将二进制数据封装成blob对象\n    const blob = new Blob([res], {\n     type: type\n   })\n   /**\n     这里也可以使用File对象封装二进制数据\n     const file = new File([res], filename, {\n       type: type\n     });\n   */\n   // 调用插件方法\n   saveAs(blob,filename)\n }\n```\n[插件源码](https://github.com/eligrey/FileSaver.js)\n##### 方法五、使用插件downloadjs\n下载插件\n```\n npm install --save downloadjs\n```\n引入插件\n```\n const download = require('downloadjs')\n```\n因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。\n\n封装下载方法，使用插件\n```\n  export const downloadFile = (res, type, filename) => {\n    // 将二进制流转成blob对象\n    const blob = new Blob([res], {\n      type: type\n    })\n    // 调用插件方法\n    download(blob, filename, type);\n  }\n\n```\n[插件源码](https://github.com/rndme/download)\n##### 二、发送请求，获取二进制流数据\n```\n// index.vue\n<template>\n  <div>\n    <button @click='handleDownload'>下载</button>\n  </div>\n</template>\n<script>\n// 引入下载方法\nimport {download} from 'utils'\nexport default{\n  methods: {\n    async downloadFile () {\n      let res = await axios.get(\n        url: 'xxxx/xxxx',\n        method: 'GET',\n        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`\n        responseType: 'blob',\n        params: {\n          id: 'xxxxxx'\n        }\n      )\n      // 获取在response headers中返回的下载文件类型\n      let type = JSON.parse(res.headers)['content-type']\n      \n      /*获取在response headers中返回的下载文件名\n        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码\n      */\n      let fileName = decodeURIComponent(JSON.parse(res.headers)['file-name'])\n      // 调用封装好的下载函数\n      download(res, type, fileName)\n    },\n    // 点击下载按钮下载\n    handleDownload() {\n      this.downloadFile()\n    }\n  }\n}\n</script>\n```\n##### 通过数据源拼接生产excel文件\n```\nconst outputExcel = () => {\n        let resultContent = 'A, B, C, D\\n'\n        let transferContent = resultContent => {\n            //根据数据 利用a标签模仿下载生成本地文件\n            let date = moment(new Date()).format('YYYY-MM-DD')\n            const blob = new Blob(['\\ufeff', resultContent], {\n                type: 'text/csv', // application/x-xls text/csv\n            })\n            const objectURL = window.URL.createObjectURL(blob)\n            const download = document.createElement('a')\n            download.href = objectURL\n            download.download = `${date}_${'文件名'}.${'csv'}`\n            download.click()\n            message.success('文件已下载')\n        }\n        let generateTxt = message => {\n            var element = document.createElement('a')\n            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(message))\n            element.setAttribute('download', '文件名' + new Date().getTime())\n            element.style.display = 'none'\n            document.body.appendChild(element)\n            element.click()\n            document.body.removeChild(element)\n        }\n        let current = 1,\n            pageSize = 8000\n\n        Modal.confirm({\n            title: '提示',\n            content: '确认导出全部信息吗？',\n            okText: '确认',\n            cancelText: '取消',\n            onOk: () => {\n                // 一次访问8000条数据的方案\n                refetch({\n                    filter: {},\n                    pager: { sort: '', current, pageSize },\n                    roleId,\n                }).then(values => {\n                    console.log('values', values)\n                    const total = values.data.allRoleUsers.total\n                    const nodes = values.data.allRoleUsers.nodes\n                    if (total > pageSize) {\n                        message.warning('用户数量太多')\n                    } else {\n                        for (let node of nodes) {\n                            let expireDate = moment(node['expireDate']).format('YYYY-MM-DD')\n                            if (expireDate === '9999-12-31') {\n                                expireDate = '永久有效'\n                            }\n                            resultContent +=\n                                node['A'] +\n                                ',' +\n                                node['B']['C'] +\n                                ',' +\n                                expireDate +\n                                ',' +\n                                moment(node['D']).format('YYYY-MM-DD') +\n                                '\\n'\n                        }\n                        // transferContent(resultContent)\n                        generateTxt(resultContent)\n                    }\n                })\n                // 轮询接口的方案\n                // const timer = setInterval(() => {\n                //     // console.log('current', current, Math.ceil(total / pageSize) + 1)\n                //     if (current < Math.ceil(total / pageSize) + 1) {\n                //         fetchMore({\n                //             variables: {\n                //                 filter: {},\n                //                 pager: { sort: '', current, pageSize },\n                //                 roleId,\n                //             },\n                //             updateQuery: (previousResult, { fetchMoreResult }) => {\n                //                 // console.log('previousResult', previousResult, fetchMoreResult)\n                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes\n                //                 for (let node of nodes) {\n                //                     resultContent +=\n                //                         node['A'] +\n                //                         ',' +\n                //                         node['B']['C'] +\n                //                         ',' +\n                //                         moment(node['D']).format('YYYY-MM-DD') +\n                //                         '\\n'\n                //                 }\n                //             },\n                //         })\n                //         current++\n                //     } else {\n                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示\n                //         const fileDateLines = resultContent.split('\\n').length - 1\n                //         if (fileDateLines === total + 1) {\n                //             transferContent(resultContent)\n                //         } else {\n                //             message.warning('数据量较大，导出数据出错，请联系管理员')\n                //         }\n                //         clearInterval(timer)\n                //     }\n                // }, 500)\n            },\n        })\n    }\n```","slug":"react前端下载后端返回的文件方法（url、二进制流）","published":1,"updated":"2025-06-22T01:39:55.185Z","layout":"post","photos":[],"link":"","_id":"cmc73233w00050xtk51uw8hzs","content":"<h3 id=\"前端下载文件有两种方式：\"><a href=\"#前端下载文件有两种方式：\" class=\"headerlink\" title=\"前端下载文件有两种方式：\"></a>前端下载文件有两种方式：</h3><p>1、通过后端返回的url，前端通过window.open(url);<br>2、后端返回的是二进制流，通过a标签实现下载。</p>\n<h5 id=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"><a href=\"#方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\" class=\"headerlink\" title=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"></a>方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。</h5><h5 id=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"><a href=\"#方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\" class=\"headerlink\" title=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"></a>方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">      method: &#x27;post&#x27;,</span><br><span class=\"line\">      url: &#x27;/api/trust/auditDownload&#x27;, //此处放hobber的内部的url</span><br><span class=\"line\">      data: params,</span><br><span class=\"line\">      responseType: &#x27;arraybuffer&#x27;, // 需要制定返回的类型，否则下载的文件会乱码</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">      // 假设 data 是返回来的二进制数据</span><br><span class=\"line\">      const data = res.data;</span><br><span class=\"line\">      const url = window.URL.createObjectURL( // type指定下载的文件的格式</span><br><span class=\"line\">        new Blob([data], &#123;</span><br><span class=\"line\">          type:</span><br><span class=\"line\">            &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">      const link = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">      link.style.display = &#x27;none&#x27;;</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.setAttribute(&#x27;download&#x27;, &#x27;excel.xlsx&#x27;); // 设置下载的文件名</span><br><span class=\"line\">      document.body.appendChild(link); </span><br><span class=\"line\">      link.click(); // 触发a标签</span><br><span class=\"line\">      document.body.removeChild(link); // 删除标签</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三、将二进制数据封装为文件读取FileReader对象\"><a href=\"#方法三、将二进制数据封装为文件读取FileReader对象\" class=\"headerlink\" title=\"方法三、将二进制数据封装为文件读取FileReader对象\"></a>方法三、将二进制数据封装为文件读取FileReader对象</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// utils.js</span><br><span class=\"line\">export const download = (res) =&gt; &#123;</span><br><span class=\"line\">  // 创建文件对象</span><br><span class=\"line\">  let reader = new FileReader()</span><br><span class=\"line\">  // 监听读取完毕</span><br><span class=\"line\">  reader.onloadend = function () &#123;</span><br><span class=\"line\">    // 返回base64位的文件内容</span><br><span class=\"line\">    let url = reader.result</span><br><span class=\"line\">    // 下载</span><br><span class=\"line\">    window.location.href = url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span><br><span class=\"line\">  reader.readAsDataURL(res)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。</p>\n<h5 id=\"方法四、使用插件file-saver\"><a href=\"#方法四、使用插件file-saver\" class=\"headerlink\" title=\"方法四、使用插件file-saver\"></a>方法四、使用插件file-saver</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save file-saver</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; saveAs &#125; from &#x27;file-saver&#x27;</span><br></pre></td></tr></table></figure>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制数据封装成blob对象</span><br><span class=\"line\">   const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  /**</span><br><span class=\"line\">    这里也可以使用File对象封装二进制数据</span><br><span class=\"line\">    const file = new File([res], filename, &#123;</span><br><span class=\"line\">      type: type</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  saveAs(blob,filename)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/eligrey/FileSaver.js\">插件源码</a></p>\n<h5 id=\"方法五、使用插件downloadjs\"><a href=\"#方法五、使用插件downloadjs\" class=\"headerlink\" title=\"方法五、使用插件downloadjs\"></a>方法五、使用插件downloadjs</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save downloadjs</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const download = require(&#x27;downloadjs&#x27;)</span><br></pre></td></tr></table></figure>\n<p>因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。</p>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制流转成blob对象</span><br><span class=\"line\">  const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  download(blob, filename, type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/rndme/download\">插件源码</a></p>\n<h5 id=\"二、发送请求，获取二进制流数据\"><a href=\"#二、发送请求，获取二进制流数据\" class=\"headerlink\" title=\"二、发送请求，获取二进制流数据\"></a>二、发送请求，获取二进制流数据</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;button @click=&#x27;handleDownload&#x27;&gt;下载&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 引入下载方法</span><br><span class=\"line\">import &#123;download&#125; from &#x27;utils&#x27;</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    async downloadFile () &#123;</span><br><span class=\"line\">      let res = await axios.get(</span><br><span class=\"line\">        url: &#x27;xxxx/xxxx&#x27;,</span><br><span class=\"line\">        method: &#x27;GET&#x27;,</span><br><span class=\"line\">        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`</span><br><span class=\"line\">        responseType: &#x27;blob&#x27;,</span><br><span class=\"line\">        params: &#123;</span><br><span class=\"line\">          id: &#x27;xxxxxx&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      // 获取在response headers中返回的下载文件类型</span><br><span class=\"line\">      let type = JSON.parse(res.headers)[&#x27;content-type&#x27;]</span><br><span class=\"line\">      </span><br><span class=\"line\">      /*获取在response headers中返回的下载文件名</span><br><span class=\"line\">        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码</span><br><span class=\"line\">      */</span><br><span class=\"line\">      let fileName = decodeURIComponent(JSON.parse(res.headers)[&#x27;file-name&#x27;])</span><br><span class=\"line\">      // 调用封装好的下载函数</span><br><span class=\"line\">      download(res, type, fileName)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 点击下载按钮下载</span><br><span class=\"line\">    handleDownload() &#123;</span><br><span class=\"line\">      this.downloadFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过数据源拼接生产excel文件\"><a href=\"#通过数据源拼接生产excel文件\" class=\"headerlink\" title=\"通过数据源拼接生产excel文件\"></a>通过数据源拼接生产excel文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const outputExcel = () =&gt; &#123;</span><br><span class=\"line\">        let resultContent = &#x27;A, B, C, D\\n&#x27;</span><br><span class=\"line\">        let transferContent = resultContent =&gt; &#123;</span><br><span class=\"line\">            //根据数据 利用a标签模仿下载生成本地文件</span><br><span class=\"line\">            let date = moment(new Date()).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">            const blob = new Blob([&#x27;\\ufeff&#x27;, resultContent], &#123;</span><br><span class=\"line\">                type: &#x27;text/csv&#x27;, // application/x-xls text/csv</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            const objectURL = window.URL.createObjectURL(blob)</span><br><span class=\"line\">            const download = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            download.href = objectURL</span><br><span class=\"line\">            download.download = `$&#123;date&#125;_$&#123;&#x27;文件名&#x27;&#125;.$&#123;&#x27;csv&#x27;&#125;`</span><br><span class=\"line\">            download.click()</span><br><span class=\"line\">            message.success(&#x27;文件已下载&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let generateTxt = message =&gt; &#123;</span><br><span class=\"line\">            var element = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            element.setAttribute(&#x27;href&#x27;, &#x27;data:text/plain;charset=utf-8,&#x27; + encodeURIComponent(message))</span><br><span class=\"line\">            element.setAttribute(&#x27;download&#x27;, &#x27;文件名&#x27; + new Date().getTime())</span><br><span class=\"line\">            element.style.display = &#x27;none&#x27;</span><br><span class=\"line\">            document.body.appendChild(element)</span><br><span class=\"line\">            element.click()</span><br><span class=\"line\">            document.body.removeChild(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let current = 1,</span><br><span class=\"line\">            pageSize = 8000</span><br><span class=\"line\"></span><br><span class=\"line\">        Modal.confirm(&#123;</span><br><span class=\"line\">            title: &#x27;提示&#x27;,</span><br><span class=\"line\">            content: &#x27;确认导出全部信息吗？&#x27;,</span><br><span class=\"line\">            okText: &#x27;确认&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">                // 一次访问8000条数据的方案</span><br><span class=\"line\">                refetch(&#123;</span><br><span class=\"line\">                    filter: &#123;&#125;,</span><br><span class=\"line\">                    pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                    roleId,</span><br><span class=\"line\">                &#125;).then(values =&gt; &#123;</span><br><span class=\"line\">                    console.log(&#x27;values&#x27;, values)</span><br><span class=\"line\">                    const total = values.data.allRoleUsers.total</span><br><span class=\"line\">                    const nodes = values.data.allRoleUsers.nodes</span><br><span class=\"line\">                    if (total &gt; pageSize) &#123;</span><br><span class=\"line\">                        message.warning(&#x27;用户数量太多&#x27;)</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        for (let node of nodes) &#123;</span><br><span class=\"line\">                            let expireDate = moment(node[&#x27;expireDate&#x27;]).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">                            if (expireDate === &#x27;9999-12-31&#x27;) &#123;</span><br><span class=\"line\">                                expireDate = &#x27;永久有效&#x27;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            resultContent +=</span><br><span class=\"line\">                                node[&#x27;A&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                expireDate +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                                &#x27;\\n&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // transferContent(resultContent)</span><br><span class=\"line\">                        generateTxt(resultContent)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                // 轮询接口的方案</span><br><span class=\"line\">                // const timer = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                //     // console.log(&#x27;current&#x27;, current, Math.ceil(total / pageSize) + 1)</span><br><span class=\"line\">                //     if (current &lt; Math.ceil(total / pageSize) + 1) &#123;</span><br><span class=\"line\">                //         fetchMore(&#123;</span><br><span class=\"line\">                //             variables: &#123;</span><br><span class=\"line\">                //                 filter: &#123;&#125;,</span><br><span class=\"line\">                //                 pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                //                 roleId,</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //             updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123;</span><br><span class=\"line\">                //                 // console.log(&#x27;previousResult&#x27;, previousResult, fetchMoreResult)</span><br><span class=\"line\">                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes</span><br><span class=\"line\">                //                 for (let node of nodes) &#123;</span><br><span class=\"line\">                //                     resultContent +=</span><br><span class=\"line\">                //                         node[&#x27;A&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                //                         &#x27;\\n&#x27;</span><br><span class=\"line\">                //                 &#125;</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //         &#125;)</span><br><span class=\"line\">                //         current++</span><br><span class=\"line\">                //     &#125; else &#123;</span><br><span class=\"line\">                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示</span><br><span class=\"line\">                //         const fileDateLines = resultContent.split(&#x27;\\n&#x27;).length - 1</span><br><span class=\"line\">                //         if (fileDateLines === total + 1) &#123;</span><br><span class=\"line\">                //             transferContent(resultContent)</span><br><span class=\"line\">                //         &#125; else &#123;</span><br><span class=\"line\">                //             message.warning(&#x27;数据量较大，导出数据出错，请联系管理员&#x27;)</span><br><span class=\"line\">                //         &#125;</span><br><span class=\"line\">                //         clearInterval(timer)</span><br><span class=\"line\">                //     &#125;</span><br><span class=\"line\">                // &#125;, 500)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前端下载文件有两种方式：\"><a href=\"#前端下载文件有两种方式：\" class=\"headerlink\" title=\"前端下载文件有两种方式：\"></a>前端下载文件有两种方式：</h3><p>1、通过后端返回的url，前端通过window.open(url);<br>2、后端返回的是二进制流，通过a标签实现下载。</p>\n<h5 id=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"><a href=\"#方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window-open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\" class=\"headerlink\" title=\"方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。\"></a>方法一：后端将静态资源放在了cdn上，返回cdn上的网址给前端。前端的window.open方法打开url时，浏览器判断当前url是资源还是页面，当是资源时进行下载，否则展示页面。</h5><h5 id=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"><a href=\"#方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\" class=\"headerlink\" title=\"方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。\"></a>方法二：后端返回二进制流。将二进制流封装成blob，这种的不推荐，当当前网速不好时，下载的数据易出错。</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">      method: &#x27;post&#x27;,</span><br><span class=\"line\">      url: &#x27;/api/trust/auditDownload&#x27;, //此处放hobber的内部的url</span><br><span class=\"line\">      data: params,</span><br><span class=\"line\">      responseType: &#x27;arraybuffer&#x27;, // 需要制定返回的类型，否则下载的文件会乱码</span><br><span class=\"line\">    &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">      // 假设 data 是返回来的二进制数据</span><br><span class=\"line\">      const data = res.data;</span><br><span class=\"line\">      const url = window.URL.createObjectURL( // type指定下载的文件的格式</span><br><span class=\"line\">        new Blob([data], &#123;</span><br><span class=\"line\">          type:</span><br><span class=\"line\">            &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">      const link = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">      link.style.display = &#x27;none&#x27;;</span><br><span class=\"line\">      link.href = url;</span><br><span class=\"line\">      link.setAttribute(&#x27;download&#x27;, &#x27;excel.xlsx&#x27;); // 设置下载的文件名</span><br><span class=\"line\">      document.body.appendChild(link); </span><br><span class=\"line\">      link.click(); // 触发a标签</span><br><span class=\"line\">      document.body.removeChild(link); // 删除标签</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三、将二进制数据封装为文件读取FileReader对象\"><a href=\"#方法三、将二进制数据封装为文件读取FileReader对象\" class=\"headerlink\" title=\"方法三、将二进制数据封装为文件读取FileReader对象\"></a>方法三、将二进制数据封装为文件读取FileReader对象</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// utils.js</span><br><span class=\"line\">export const download = (res) =&gt; &#123;</span><br><span class=\"line\">  // 创建文件对象</span><br><span class=\"line\">  let reader = new FileReader()</span><br><span class=\"line\">  // 监听读取完毕</span><br><span class=\"line\">  reader.onloadend = function () &#123;</span><br><span class=\"line\">    // 返回base64位的文件内容</span><br><span class=\"line\">    let url = reader.result</span><br><span class=\"line\">    // 下载</span><br><span class=\"line\">    window.location.href = url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span><br><span class=\"line\">  reader.readAsDataURL(res)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意： 使用 FileReader对象封装二进制流之后没办法设置下载的文件名，默认文件名为下载，文件格式根据读取的是请求返回的content-type。</p>\n<h5 id=\"方法四、使用插件file-saver\"><a href=\"#方法四、使用插件file-saver\" class=\"headerlink\" title=\"方法四、使用插件file-saver\"></a>方法四、使用插件file-saver</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save file-saver</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; saveAs &#125; from &#x27;file-saver&#x27;</span><br></pre></td></tr></table></figure>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制数据封装成blob对象</span><br><span class=\"line\">   const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  /**</span><br><span class=\"line\">    这里也可以使用File对象封装二进制数据</span><br><span class=\"line\">    const file = new File([res], filename, &#123;</span><br><span class=\"line\">      type: type</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  saveAs(blob,filename)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/eligrey/FileSaver.js\">插件源码</a></p>\n<h5 id=\"方法五、使用插件downloadjs\"><a href=\"#方法五、使用插件downloadjs\" class=\"headerlink\" title=\"方法五、使用插件downloadjs\"></a>方法五、使用插件downloadjs</h5><p>下载插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save downloadjs</span><br></pre></td></tr></table></figure>\n<p>引入插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const download = require(&#x27;downloadjs&#x27;)</span><br></pre></td></tr></table></figure>\n<p>因为downloadjs源码中没有通过export导出download方法，而是通过return的方式返回download方法，因为需要使用require来引入文件。</p>\n<p>封装下载方法，使用插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const downloadFile = (res, type, filename) =&gt; &#123;</span><br><span class=\"line\">  // 将二进制流转成blob对象</span><br><span class=\"line\">  const blob = new Blob([res], &#123;</span><br><span class=\"line\">    type: type</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 调用插件方法</span><br><span class=\"line\">  download(blob, filename, type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/rndme/download\">插件源码</a></p>\n<h5 id=\"二、发送请求，获取二进制流数据\"><a href=\"#二、发送请求，获取二进制流数据\" class=\"headerlink\" title=\"二、发送请求，获取二进制流数据\"></a>二、发送请求，获取二进制流数据</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;button @click=&#x27;handleDownload&#x27;&gt;下载&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 引入下载方法</span><br><span class=\"line\">import &#123;download&#125; from &#x27;utils&#x27;</span><br><span class=\"line\">export default&#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    async downloadFile () &#123;</span><br><span class=\"line\">      let res = await axios.get(</span><br><span class=\"line\">        url: &#x27;xxxx/xxxx&#x27;,</span><br><span class=\"line\">        method: &#x27;GET&#x27;,</span><br><span class=\"line\">        // 设置返回数据类型，这里一定要设置，否则下载下来的文件会是空白,也可以是`arraybuffer`</span><br><span class=\"line\">        responseType: &#x27;blob&#x27;,</span><br><span class=\"line\">        params: &#123;</span><br><span class=\"line\">          id: &#x27;xxxxxx&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      // 获取在response headers中返回的下载文件类型</span><br><span class=\"line\">      let type = JSON.parse(res.headers)[&#x27;content-type&#x27;]</span><br><span class=\"line\">      </span><br><span class=\"line\">      /*获取在response headers中返回的下载文件名</span><br><span class=\"line\">        因为返回文件名是通过encodeURIComponent()函数进行了编码，因此需要通过decodeURIComponent()函数解码</span><br><span class=\"line\">      */</span><br><span class=\"line\">      let fileName = decodeURIComponent(JSON.parse(res.headers)[&#x27;file-name&#x27;])</span><br><span class=\"line\">      // 调用封装好的下载函数</span><br><span class=\"line\">      download(res, type, fileName)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 点击下载按钮下载</span><br><span class=\"line\">    handleDownload() &#123;</span><br><span class=\"line\">      this.downloadFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过数据源拼接生产excel文件\"><a href=\"#通过数据源拼接生产excel文件\" class=\"headerlink\" title=\"通过数据源拼接生产excel文件\"></a>通过数据源拼接生产excel文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const outputExcel = () =&gt; &#123;</span><br><span class=\"line\">        let resultContent = &#x27;A, B, C, D\\n&#x27;</span><br><span class=\"line\">        let transferContent = resultContent =&gt; &#123;</span><br><span class=\"line\">            //根据数据 利用a标签模仿下载生成本地文件</span><br><span class=\"line\">            let date = moment(new Date()).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">            const blob = new Blob([&#x27;\\ufeff&#x27;, resultContent], &#123;</span><br><span class=\"line\">                type: &#x27;text/csv&#x27;, // application/x-xls text/csv</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            const objectURL = window.URL.createObjectURL(blob)</span><br><span class=\"line\">            const download = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            download.href = objectURL</span><br><span class=\"line\">            download.download = `$&#123;date&#125;_$&#123;&#x27;文件名&#x27;&#125;.$&#123;&#x27;csv&#x27;&#125;`</span><br><span class=\"line\">            download.click()</span><br><span class=\"line\">            message.success(&#x27;文件已下载&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let generateTxt = message =&gt; &#123;</span><br><span class=\"line\">            var element = document.createElement(&#x27;a&#x27;)</span><br><span class=\"line\">            element.setAttribute(&#x27;href&#x27;, &#x27;data:text/plain;charset=utf-8,&#x27; + encodeURIComponent(message))</span><br><span class=\"line\">            element.setAttribute(&#x27;download&#x27;, &#x27;文件名&#x27; + new Date().getTime())</span><br><span class=\"line\">            element.style.display = &#x27;none&#x27;</span><br><span class=\"line\">            document.body.appendChild(element)</span><br><span class=\"line\">            element.click()</span><br><span class=\"line\">            document.body.removeChild(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let current = 1,</span><br><span class=\"line\">            pageSize = 8000</span><br><span class=\"line\"></span><br><span class=\"line\">        Modal.confirm(&#123;</span><br><span class=\"line\">            title: &#x27;提示&#x27;,</span><br><span class=\"line\">            content: &#x27;确认导出全部信息吗？&#x27;,</span><br><span class=\"line\">            okText: &#x27;确认&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">                // 一次访问8000条数据的方案</span><br><span class=\"line\">                refetch(&#123;</span><br><span class=\"line\">                    filter: &#123;&#125;,</span><br><span class=\"line\">                    pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                    roleId,</span><br><span class=\"line\">                &#125;).then(values =&gt; &#123;</span><br><span class=\"line\">                    console.log(&#x27;values&#x27;, values)</span><br><span class=\"line\">                    const total = values.data.allRoleUsers.total</span><br><span class=\"line\">                    const nodes = values.data.allRoleUsers.nodes</span><br><span class=\"line\">                    if (total &gt; pageSize) &#123;</span><br><span class=\"line\">                        message.warning(&#x27;用户数量太多&#x27;)</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        for (let node of nodes) &#123;</span><br><span class=\"line\">                            let expireDate = moment(node[&#x27;expireDate&#x27;]).format(&#x27;YYYY-MM-DD&#x27;)</span><br><span class=\"line\">                            if (expireDate === &#x27;9999-12-31&#x27;) &#123;</span><br><span class=\"line\">                                expireDate = &#x27;永久有效&#x27;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            resultContent +=</span><br><span class=\"line\">                                node[&#x27;A&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                expireDate +</span><br><span class=\"line\">                                &#x27;,&#x27; +</span><br><span class=\"line\">                                moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                                &#x27;\\n&#x27;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        // transferContent(resultContent)</span><br><span class=\"line\">                        generateTxt(resultContent)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                // 轮询接口的方案</span><br><span class=\"line\">                // const timer = setInterval(() =&gt; &#123;</span><br><span class=\"line\">                //     // console.log(&#x27;current&#x27;, current, Math.ceil(total / pageSize) + 1)</span><br><span class=\"line\">                //     if (current &lt; Math.ceil(total / pageSize) + 1) &#123;</span><br><span class=\"line\">                //         fetchMore(&#123;</span><br><span class=\"line\">                //             variables: &#123;</span><br><span class=\"line\">                //                 filter: &#123;&#125;,</span><br><span class=\"line\">                //                 pager: &#123; sort: &#x27;&#x27;, current, pageSize &#125;,</span><br><span class=\"line\">                //                 roleId,</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //             updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123;</span><br><span class=\"line\">                //                 // console.log(&#x27;previousResult&#x27;, previousResult, fetchMoreResult)</span><br><span class=\"line\">                //                 const nodes = fetchMoreResult?.allRoleUsers?.nodes</span><br><span class=\"line\">                //                 for (let node of nodes) &#123;</span><br><span class=\"line\">                //                     resultContent +=</span><br><span class=\"line\">                //                         node[&#x27;A&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         node[&#x27;B&#x27;][&#x27;C&#x27;] +</span><br><span class=\"line\">                //                         &#x27;,&#x27; +</span><br><span class=\"line\">                //                         moment(node[&#x27;D&#x27;]).format(&#x27;YYYY-MM-DD&#x27;) +</span><br><span class=\"line\">                //                         &#x27;\\n&#x27;</span><br><span class=\"line\">                //                 &#125;</span><br><span class=\"line\">                //             &#125;,</span><br><span class=\"line\">                //         &#125;)</span><br><span class=\"line\">                //         current++</span><br><span class=\"line\">                //     &#125; else &#123;</span><br><span class=\"line\">                //         // 校验下载量是否与total值一致，一致则下载，反之则给出提示</span><br><span class=\"line\">                //         const fileDateLines = resultContent.split(&#x27;\\n&#x27;).length - 1</span><br><span class=\"line\">                //         if (fileDateLines === total + 1) &#123;</span><br><span class=\"line\">                //             transferContent(resultContent)</span><br><span class=\"line\">                //         &#125; else &#123;</span><br><span class=\"line\">                //             message.warning(&#x27;数据量较大，导出数据出错，请联系管理员&#x27;)</span><br><span class=\"line\">                //         &#125;</span><br><span class=\"line\">                //         clearInterval(timer)</span><br><span class=\"line\">                //     &#125;</span><br><span class=\"line\">                // &#125;, 500)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"检测后端接口常见方法","date":"2022-05-22T14:36:45.000Z","comments":1,"_content":"### 痛点，常常由于不知道后端接口是否可用而苦恼\n#### 方法一：curl实现，post请求\n    1、复制浏览器的curl链接，\n    2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    3、删除掉原有的orgin和referer字段，\n    -H 请求头\n    --data-row：请求体\n    -x：请求协议\n#### 方法二：通过浏览器网址直接访问，get请求\n    1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    容易由于鉴权问题出现错误。\n#### 方法三：通过postman调用接口\n    1、配置后端的域名和接口地址环境\n    2、配置请求头\n    3、配置请求体","source":"_posts/检测后端接口常见方法.md","raw":"---\ntitle: 检测后端接口常见方法\ndate: 2022-05-22 22:36:45\ntags: 后端接口\ncategories: 后端接口\ncomments: true\n---\n### 痛点，常常由于不知道后端接口是否可用而苦恼\n#### 方法一：curl实现，post请求\n    1、复制浏览器的curl链接，\n    2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    3、删除掉原有的orgin和referer字段，\n    -H 请求头\n    --data-row：请求体\n    -x：请求协议\n#### 方法二：通过浏览器网址直接访问，get请求\n    1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n    容易由于鉴权问题出现错误。\n#### 方法三：通过postman调用接口\n    1、配置后端的域名和接口地址环境\n    2、配置请求头\n    3、配置请求体","slug":"检测后端接口常见方法","published":1,"updated":"2025-06-22T01:39:55.186Z","layout":"post","photos":[],"link":"","_id":"cmc73233x00060xtkfban1nkj","content":"<h3 id=\"痛点，常常由于不知道后端接口是否可用而苦恼\"><a href=\"#痛点，常常由于不知道后端接口是否可用而苦恼\" class=\"headerlink\" title=\"痛点，常常由于不知道后端接口是否可用而苦恼\"></a>痛点，常常由于不知道后端接口是否可用而苦恼</h3><h4 id=\"方法一：curl实现，post请求\"><a href=\"#方法一：curl实现，post请求\" class=\"headerlink\" title=\"方法一：curl实现，post请求\"></a>方法一：curl实现，post请求</h4><pre><code>1、复制浏览器的curl链接，\n2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n3、删除掉原有的orgin和referer字段，\n-H 请求头\n--data-row：请求体\n-x：请求协议\n</code></pre>\n<h4 id=\"方法二：通过浏览器网址直接访问，get请求\"><a href=\"#方法二：通过浏览器网址直接访问，get请求\" class=\"headerlink\" title=\"方法二：通过浏览器网址直接访问，get请求\"></a>方法二：通过浏览器网址直接访问，get请求</h4><pre><code>1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n容易由于鉴权问题出现错误。\n</code></pre>\n<h4 id=\"方法三：通过postman调用接口\"><a href=\"#方法三：通过postman调用接口\" class=\"headerlink\" title=\"方法三：通过postman调用接口\"></a>方法三：通过postman调用接口</h4><pre><code>1、配置后端的域名和接口地址环境\n2、配置请求头\n3、配置请求体\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"痛点，常常由于不知道后端接口是否可用而苦恼\"><a href=\"#痛点，常常由于不知道后端接口是否可用而苦恼\" class=\"headerlink\" title=\"痛点，常常由于不知道后端接口是否可用而苦恼\"></a>痛点，常常由于不知道后端接口是否可用而苦恼</h3><h4 id=\"方法一：curl实现，post请求\"><a href=\"#方法一：curl实现，post请求\" class=\"headerlink\" title=\"方法一：curl实现，post请求\"></a>方法一：curl实现，post请求</h4><pre><code>1、复制浏览器的curl链接，\n2、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n3、删除掉原有的orgin和referer字段，\n-H 请求头\n--data-row：请求体\n-x：请求协议\n</code></pre>\n<h4 id=\"方法二：通过浏览器网址直接访问，get请求\"><a href=\"#方法二：通过浏览器网址直接访问，get请求\" class=\"headerlink\" title=\"方法二：通过浏览器网址直接访问，get请求\"></a>方法二：通过浏览器网址直接访问，get请求</h4><pre><code>1、用后端服务器地址和接口地址拼接替换掉curl中的请求地址\n容易由于鉴权问题出现错误。\n</code></pre>\n<h4 id=\"方法三：通过postman调用接口\"><a href=\"#方法三：通过postman调用接口\" class=\"headerlink\" title=\"方法三：通过postman调用接口\"></a>方法三：通过postman调用接口</h4><pre><code>1、配置后端的域名和接口地址环境\n2、配置请求头\n3、配置请求体\n</code></pre>\n"},{"title":"每天一个新问题（永远保持怀疑）","date":"2022-05-22T14:49:29.000Z","_content":"1、\\<\\> 、\\<React.Fragment\\>与\\<div\\>。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。\n    \n######     答案：\n```jsx\n// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，<> 和 <React.Fragment>中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）\n    <Form.Item name=\"opterator\" label=\"操作人：\">\n                <div  onChange={e=>{\n                  console.log(\"gerd => \" ,e)\n                }}>\n                <>\n                <div onChange={e=>{\n                  console.log(e);\n                  e.stopPropagation(); //阻止冒泡后，获取不到值\n                }}>\n                  <input\n                    // style={{ width: '75%' }}\n                    placeholder=\"请输入操作人\"\n                  />\n                </div>\n              </>\n             </div>\n        </Form.Item>\n```\n    \n \n2、antd的select的默认属性值在form表单中不起作用，获取的是undefined\n    \n  ######     答案\n  >form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。\n>\n\n3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。\n    \n######     解答\n    \n>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: [...data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。\n>\n\n4、 当我们开发时，经常遇到antd中日期选择器的时间处理。\n    \n######     解答\n```js\n// 通过monent函数转化，当然，monent需要引入函数库；import monent from 'monent';\nstartDate = moment(value.findDate[0].format('YYYY-MM-DD HH:mm:ss'));// 转化为开始日期\nendDate = moment(value.findDate[1].format('YYYY-MM-DD HH:mm:ss'));// 转化为结束日期\n// 此处的x为datepicker的value值哟。\n日期=》时间戳： x.unix()\n时间戳=》日期：moment( new Date(x * 1000 ))\n```\n    \n5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。\n    \n###### 郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\n>1）、redux\n>2）、将状态放在上级组件中存储 \n>3）、放在sessionstorage或localstorage中存储\n>\n\n优缺点：redux可避免状态外漏\n    \n\n| 序号 | 方法 |优点  | 缺点 |\n| --- | --- | --- | --- |\n|1  | redux | 避免状态信息的泄漏 | 每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值 |\n| 2 |将状态放在上级组件中存储  |  通过组件的props传值，获取值时机可靠|  组件间耦合关系太深，开发繁琐 |\n| 3 |放在sessionstorage或localstorage中存储  |  存储值方便|当页面跳转时，无法有效的删除storage和在session中泄露状态信息  |\n|4|放在url中存储 |方便页面跳转获取参数  |  当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密|\n\n```\n6、<a href=\"#\"></a>标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。\n    <Prompt\n      when={this.state.submit} // sunmit为提交按钮状态 默认为false\n      message={location => {\n        if (this.state.submit) {\n          Modal.confirm({\n            icon: <ExclamationCircleOutlined />,\n            content: '暂未提交您所做的更改，是否提交',\n            okText: '继续加载',\n            cancelText: '取消',\n            onOk: () => {\n              this.setState({ submit: false }, () => {\n                this.props.history.push(`${location.pathname}`);\n              });\n            },\n            onCancel: () => {},\n          });\n          return false; // 返回false时，阻塞路由跳转\n        }\n        return true; // 返回true时，路由跳转\n      }}\n```\n7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！\n \n8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新\n######     解答\n        react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。\n 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。\n######         坑\n       当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。\n######         解答\n        通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）","source":"_posts/每天一个新问题（永远保持怀疑）.md","raw":"---\ntitle: 每天一个新问题（永远保持怀疑）\ndate: 2022-05-22 22:49:29\ntag: 持续更新（ing）\n---\n1、\\<\\> 、\\<React.Fragment\\>与\\<div\\>。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。\n    \n######     答案：\n```jsx\n// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，<> 和 <React.Fragment>中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）\n    <Form.Item name=\"opterator\" label=\"操作人：\">\n                <div  onChange={e=>{\n                  console.log(\"gerd => \" ,e)\n                }}>\n                <>\n                <div onChange={e=>{\n                  console.log(e);\n                  e.stopPropagation(); //阻止冒泡后，获取不到值\n                }}>\n                  <input\n                    // style={{ width: '75%' }}\n                    placeholder=\"请输入操作人\"\n                  />\n                </div>\n              </>\n             </div>\n        </Form.Item>\n```\n    \n \n2、antd的select的默认属性值在form表单中不起作用，获取的是undefined\n    \n  ######     答案\n  >form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。\n>\n\n3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。\n    \n######     解答\n    \n>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: [...data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。\n>\n\n4、 当我们开发时，经常遇到antd中日期选择器的时间处理。\n    \n######     解答\n```js\n// 通过monent函数转化，当然，monent需要引入函数库；import monent from 'monent';\nstartDate = moment(value.findDate[0].format('YYYY-MM-DD HH:mm:ss'));// 转化为开始日期\nendDate = moment(value.findDate[1].format('YYYY-MM-DD HH:mm:ss'));// 转化为结束日期\n// 此处的x为datepicker的value值哟。\n日期=》时间戳： x.unix()\n时间戳=》日期：moment( new Date(x * 1000 ))\n```\n    \n5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。\n    \n###### 郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\n>1）、redux\n>2）、将状态放在上级组件中存储 \n>3）、放在sessionstorage或localstorage中存储\n>\n\n优缺点：redux可避免状态外漏\n    \n\n| 序号 | 方法 |优点  | 缺点 |\n| --- | --- | --- | --- |\n|1  | redux | 避免状态信息的泄漏 | 每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值 |\n| 2 |将状态放在上级组件中存储  |  通过组件的props传值，获取值时机可靠|  组件间耦合关系太深，开发繁琐 |\n| 3 |放在sessionstorage或localstorage中存储  |  存储值方便|当页面跳转时，无法有效的删除storage和在session中泄露状态信息  |\n|4|放在url中存储 |方便页面跳转获取参数  |  当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密|\n\n```\n6、<a href=\"#\"></a>标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。\n    <Prompt\n      when={this.state.submit} // sunmit为提交按钮状态 默认为false\n      message={location => {\n        if (this.state.submit) {\n          Modal.confirm({\n            icon: <ExclamationCircleOutlined />,\n            content: '暂未提交您所做的更改，是否提交',\n            okText: '继续加载',\n            cancelText: '取消',\n            onOk: () => {\n              this.setState({ submit: false }, () => {\n                this.props.history.push(`${location.pathname}`);\n              });\n            },\n            onCancel: () => {},\n          });\n          return false; // 返回false时，阻塞路由跳转\n        }\n        return true; // 返回true时，路由跳转\n      }}\n```\n7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！\n \n8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新\n######     解答\n        react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。\n 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。\n######         坑\n       当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。\n######         解答\n        通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）","slug":"每天一个新问题（永远保持怀疑）","published":1,"updated":"2025-06-22T01:39:55.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc73233z000a0xtk9byshkh6","content":"<p>1、&lt;&gt; 、&lt;React.Fragment&gt;与&lt;div&gt;。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。</p>\n<h6 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h6><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，&lt;&gt; 和 &lt;React.Fragment&gt;中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）</span></span><br><span class=\"line\">    &lt;<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span> name=<span class=\"string\">&quot;opterator&quot;</span> label=<span class=\"string\">&quot;操作人：&quot;</span>&gt;</span><br><span class=\"line\">                <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>  <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(&quot;gerd =&gt; &quot; ,e)</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(e);</span></span><br><span class=\"line\"><span class=\"language-xml\">                  e.stopPropagation(); //阻止冒泡后，获取不到值</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    // <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> &#x27;<span class=\"attr\">75</span>%&#x27; &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入操作人&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">        &lt;/<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>2、antd的select的默认属性值在form表单中不起作用，获取的是undefined</p>\n<h6 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h6><blockquote>\n<p>form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。</p>\n</blockquote>\n<p>3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。</p>\n<h6 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h6><blockquote>\n<p>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: […data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。</p>\n</blockquote>\n<p>4、 当我们开发时，经常遇到antd中日期选择器的时间处理。</p>\n<h6 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过monent函数转化，当然，monent需要引入函数库；import monent from &#x27;monent&#x27;;</span></span><br><span class=\"line\">startDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">0</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为开始日期</span></span><br><span class=\"line\">endDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">1</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为结束日期</span></span><br><span class=\"line\"><span class=\"comment\">// 此处的x为datepicker的value值哟。</span></span><br><span class=\"line\">日期=》时间戳： x.<span class=\"title function_\">unix</span>()</span><br><span class=\"line\">时间戳=》日期：<span class=\"title function_\">moment</span>( <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(x * <span class=\"number\">1000</span> ))</span><br></pre></td></tr></table></figure>\n<p>5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。</p>\n<h6 id=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"><a href=\"#郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\" class=\"headerlink\" title=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"></a>郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。</h6><blockquote>\n<p>1）、redux<br>2）、将状态放在上级组件中存储<br>3）、放在sessionstorage或localstorage中存储</p>\n</blockquote>\n<p>优缺点：redux可避免状态外漏</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>redux</td>\n<td>避免状态信息的泄漏</td>\n<td>每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将状态放在上级组件中存储</td>\n<td>通过组件的props传值，获取值时机可靠</td>\n<td>组件间耦合关系太深，开发繁琐</td>\n</tr>\n<tr>\n<td>3</td>\n<td>放在sessionstorage或localstorage中存储</td>\n<td>存储值方便</td>\n<td>当页面跳转时，无法有效的删除storage和在session中泄露状态信息</td>\n</tr>\n<tr>\n<td>4</td>\n<td>放在url中存储</td>\n<td>方便页面跳转获取参数</td>\n<td>当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6、&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。</span><br><span class=\"line\">    &lt;Prompt</span><br><span class=\"line\">      when=&#123;this.state.submit&#125; // sunmit为提交按钮状态 默认为false</span><br><span class=\"line\">      message=&#123;location =&gt; &#123;</span><br><span class=\"line\">        if (this.state.submit) &#123;</span><br><span class=\"line\">          Modal.confirm(&#123;</span><br><span class=\"line\">            icon: &lt;ExclamationCircleOutlined /&gt;,</span><br><span class=\"line\">            content: &#x27;暂未提交您所做的更改，是否提交&#x27;,</span><br><span class=\"line\">            okText: &#x27;继续加载&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">              this.setState(&#123; submit: false &#125;, () =&gt; &#123;</span><br><span class=\"line\">                this.props.history.push(`$&#123;location.pathname&#125;`);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onCancel: () =&gt; &#123;&#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          return false; // 返回false时，阻塞路由跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true; // 返回true时，路由跳转</span><br><span class=\"line\">      &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！</p>\n<p>8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新</p>\n<h6 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n</code></pre>\n<p> 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。<br> 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。</p>\n<h6 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h6><pre><code>   当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n</code></pre>\n<p>11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。</p>\n<h6 id=\"解答-3\"><a href=\"#解答-3\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>1、&lt;&gt; 、&lt;React.Fragment&gt;与&lt;div&gt;。前两者作为代码块插入的form表单中，form表单无法获取其值，后者可以获得。</p>\n<h6 id=\"答案：\"><a href=\"#答案：\" class=\"headerlink\" title=\"答案：\"></a>答案：</h6><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，&lt;&gt; 和 &lt;React.Fragment&gt;中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）</span></span><br><span class=\"line\">    &lt;<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span> name=<span class=\"string\">&quot;opterator&quot;</span> label=<span class=\"string\">&quot;操作人：&quot;</span>&gt;</span><br><span class=\"line\">                <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>  <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(&quot;gerd =&gt; &quot; ,e)</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  console.log(e);</span></span><br><span class=\"line\"><span class=\"language-xml\">                  e.stopPropagation(); //阻止冒泡后，获取不到值</span></span><br><span class=\"line\"><span class=\"language-xml\">                &#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    // <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">width:</span> &#x27;<span class=\"attr\">75</span>%&#x27; &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;请输入操作人&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">             &lt;/div&gt;</span><br><span class=\"line\">        &lt;/<span class=\"title class_\">Form</span>.<span class=\"property\">Item</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>2、antd的select的默认属性值在form表单中不起作用，获取的是undefined</p>\n<h6 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h6><blockquote>\n<p>form表单中控件的值默认初始化只能通过form的initialValues和setFieldsValue进行初始化，form.item内部控件中的defaultvalue值只能展示，但是当获取时，通过form的value为undefined。</p>\n</blockquote>\n<p>3、this.setstate({data}),为了代码的简略性，常常使用es6的特性。易出现state值发生了变化，但是render函数并未触发。</p>\n<h6 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h6><blockquote>\n<p>react的this.setstate方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过this.setstate({data: […data]})的方式，将数组拆分赋值，实现引用的变化来触发render函数。</p>\n</blockquote>\n<p>4、 当我们开发时，经常遇到antd中日期选择器的时间处理。</p>\n<h6 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过monent函数转化，当然，monent需要引入函数库；import monent from &#x27;monent&#x27;;</span></span><br><span class=\"line\">startDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">0</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为开始日期</span></span><br><span class=\"line\">endDate = <span class=\"title function_\">moment</span>(value.<span class=\"property\">findDate</span>[<span class=\"number\">1</span>].<span class=\"title function_\">format</span>(<span class=\"string\">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));<span class=\"comment\">// 转化为结束日期</span></span><br><span class=\"line\"><span class=\"comment\">// 此处的x为datepicker的value值哟。</span></span><br><span class=\"line\">日期=》时间戳： x.<span class=\"title function_\">unix</span>()</span><br><span class=\"line\">时间戳=》日期：<span class=\"title function_\">moment</span>( <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(x * <span class=\"number\">1000</span> ))</span><br></pre></td></tr></table></figure>\n<p>5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。</p>\n<h6 id=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"><a href=\"#郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\" class=\"headerlink\" title=\"郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。\"></a>郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。</h6><blockquote>\n<p>1）、redux<br>2）、将状态放在上级组件中存储<br>3）、放在sessionstorage或localstorage中存储</p>\n</blockquote>\n<p>优缺点：redux可避免状态外漏</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>redux</td>\n<td>避免状态信息的泄漏</td>\n<td>每次不可以刷新页面进入，需通过路由跳转才能获取props中redux的值</td>\n</tr>\n<tr>\n<td>2</td>\n<td>将状态放在上级组件中存储</td>\n<td>通过组件的props传值，获取值时机可靠</td>\n<td>组件间耦合关系太深，开发繁琐</td>\n</tr>\n<tr>\n<td>3</td>\n<td>放在sessionstorage或localstorage中存储</td>\n<td>存储值方便</td>\n<td>当页面跳转时，无法有效的删除storage和在session中泄露状态信息</td>\n</tr>\n<tr>\n<td>4</td>\n<td>放在url中存储</td>\n<td>方便页面跳转获取参数</td>\n<td>当状态信息过多时，超出url长度。对于泄漏参数信息可以通过加密实现，最简单的window.btoa()和window.atob();window.atob()进行加密</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6、&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。</span><br><span class=\"line\">    &lt;Prompt</span><br><span class=\"line\">      when=&#123;this.state.submit&#125; // sunmit为提交按钮状态 默认为false</span><br><span class=\"line\">      message=&#123;location =&gt; &#123;</span><br><span class=\"line\">        if (this.state.submit) &#123;</span><br><span class=\"line\">          Modal.confirm(&#123;</span><br><span class=\"line\">            icon: &lt;ExclamationCircleOutlined /&gt;,</span><br><span class=\"line\">            content: &#x27;暂未提交您所做的更改，是否提交&#x27;,</span><br><span class=\"line\">            okText: &#x27;继续加载&#x27;,</span><br><span class=\"line\">            cancelText: &#x27;取消&#x27;,</span><br><span class=\"line\">            onOk: () =&gt; &#123;</span><br><span class=\"line\">              this.setState(&#123; submit: false &#125;, () =&gt; &#123;</span><br><span class=\"line\">                this.props.history.push(`$&#123;location.pathname&#125;`);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            onCancel: () =&gt; &#123;&#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          return false; // 返回false时，阻塞路由跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true; // 返回true时，路由跳转</span><br><span class=\"line\">      &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>7、永远不要修改this.state里的对象，要用lodash的cloneDeep实现对象隔离。chrome也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！</p>\n<p>8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新</p>\n<h6 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。\n</code></pre>\n<p> 9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当url变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。<br> 10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。</p>\n<h6 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h6><pre><code>   当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。\n</code></pre>\n<p>11、antd的版本包问题：antdesign/proprolayout依赖安装ant时，它默认安装最新的antd版本包。但是antd的版本包易出错，导致网站样式错误。</p>\n<h6 id=\"解答-3\"><a href=\"#解答-3\" class=\"headerlink\" title=\"解答\"></a>解答</h6><pre><code>    通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）\n</code></pre>\n"},{"title":"浏览器安全","date":"2022-05-24T01:12:51.000Z","_content":"# 浏览器安全\n\n## web网页安全\n\n### 同源策略\n\n- 协议、域名和端口都相同\n- 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的\n- 主要表现在 DOM、Web 数据和网络这三个层面\n- 跨域共享数据\n\n\t- cros\n\n- 跨文档共享消息\n\n\t- 操作dom\n\t- postMessage\n\n### CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\n\n### xss\n\n- 恶意代码注入攻击\n\n\t- 存储型攻击\n\n\t\t- 将恶意脚本发送给服务器，服务器存储在数据库中\n\n\t- 反射型攻击\n\n\t\t- 不存储，将恶意脚本由服务器再返回给浏览器\n\n\t- 基于 DOM 的 XSS 攻击\n\n\t\t- 在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据\n\n- 阻止策略\n\n\t- 原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。\n\t- 1、服务器对输入脚本进行过滤或转码\n\t- 2. 充分利用 CSP\n\n\t\t- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；\n\t\t- 禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；\n\t\t- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。\n\n\t- 3. 使用 HttpOnly 属性\n\n\t\t- 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。\n\t\t- httpOnly由响应头设置\n\n###  CSRF 攻击，\n\n- CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事\n\n\t- 1、自动发送get请求\n\t- 2、自动发送post请求\n\t- 3、引诱用户点击链接\n\t- 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n- 阻止攻击\n\n\t- 1. 充分利用好 Cookie 的 SameSite 属性\n\n\t\t- 在set-cookie时设置\n\t\t- strict\n\n\t\t\t- 完全禁止第三方站点请求带上cookie\n\n\t\t- lax\n\n\t\t\t- 运行get请求\n\n\t\t\t\t- post，img，iframe加载url时不允许的\n\n\t\t- none\n\n\t\t\t- 完全开放请求\n\n\t- 2. 验证请求的来源站点\n\n\t\t- Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。\n\t\t- Origin 和 Referer 的一个主要区别。\n\n\t\t\t- Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，\n\t\t\t- origin更优先\n\n\t- 3. CSRF Token\n\n\t\t- 有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息\n\t\t- 第三方站点没有对应的csrf token\n\n## 浏览器系统安全\n\n### 安全沙箱\n![安全沙箱](安全沙箱.png)\n\n- 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。\n- 浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。\n- 安全沙箱最小的保护单位是进程。\n\n![渲染进程与浏览器内核](渲染进程与浏览器内核.png) \n\n### 无法阻止xss，csrf的攻击\n\n## 浏览器网络安全\n\n![浏览器安全](浏览器安全.png)\n\n### https加解密\n\n- 对称加密\n\n\t- 对称加密是指加密和解密都使用的是相同的密钥。\n\n![对称加密](对称加密.png)\n\n- 非对称加密\n\n\t- 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加\n密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来\n解密。\n\n![非对称加密](非对称加密.png)\n\n\t- 缺点\n\n\t\t- 第一个是非对称加密的效率太低。\n\t\t- 第二个是无法保证服务器发送给浏览器的数据安全。\n\n- 对称加密和非对称加密搭配使用\n\n\t- 在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。\n\n![对称混合非对称加密](对称混合非对称加密.png)\n\n- 添加数字证书\n\n![数字证书](数字证书.png)\n\n\t- ca证书中包含公司信息，公钥，等。\n\t- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n\t\t- 证书验证\n\n\t\t\t- 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n\n","source":"_posts/浏览器安全.md","raw":"---\ntitle: 浏览器安全\ndate: 2022-05-24 09:12:51\ntags: 安全\n---\n# 浏览器安全\n\n## web网页安全\n\n### 同源策略\n\n- 协议、域名和端口都相同\n- 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的\n- 主要表现在 DOM、Web 数据和网络这三个层面\n- 跨域共享数据\n\n\t- cros\n\n- 跨文档共享消息\n\n\t- 操作dom\n\t- postMessage\n\n### CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\n\n### xss\n\n- 恶意代码注入攻击\n\n\t- 存储型攻击\n\n\t\t- 将恶意脚本发送给服务器，服务器存储在数据库中\n\n\t- 反射型攻击\n\n\t\t- 不存储，将恶意脚本由服务器再返回给浏览器\n\n\t- 基于 DOM 的 XSS 攻击\n\n\t\t- 在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据\n\n- 阻止策略\n\n\t- 原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。\n\t- 1、服务器对输入脚本进行过滤或转码\n\t- 2. 充分利用 CSP\n\n\t\t- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；\n\t\t- 禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；\n\t\t- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。\n\n\t- 3. 使用 HttpOnly 属性\n\n\t\t- 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。\n\t\t- httpOnly由响应头设置\n\n###  CSRF 攻击，\n\n- CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事\n\n\t- 1、自动发送get请求\n\t- 2、自动发送post请求\n\t- 3、引诱用户点击链接\n\t- 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n- 阻止攻击\n\n\t- 1. 充分利用好 Cookie 的 SameSite 属性\n\n\t\t- 在set-cookie时设置\n\t\t- strict\n\n\t\t\t- 完全禁止第三方站点请求带上cookie\n\n\t\t- lax\n\n\t\t\t- 运行get请求\n\n\t\t\t\t- post，img，iframe加载url时不允许的\n\n\t\t- none\n\n\t\t\t- 完全开放请求\n\n\t- 2. 验证请求的来源站点\n\n\t\t- Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。\n\t\t- Origin 和 Referer 的一个主要区别。\n\n\t\t\t- Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，\n\t\t\t- origin更优先\n\n\t- 3. CSRF Token\n\n\t\t- 有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息\n\t\t- 第三方站点没有对应的csrf token\n\n## 浏览器系统安全\n\n### 安全沙箱\n![安全沙箱](安全沙箱.png)\n\n- 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。\n- 浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。\n- 安全沙箱最小的保护单位是进程。\n\n![渲染进程与浏览器内核](渲染进程与浏览器内核.png) \n\n### 无法阻止xss，csrf的攻击\n\n## 浏览器网络安全\n\n![浏览器安全](浏览器安全.png)\n\n### https加解密\n\n- 对称加密\n\n\t- 对称加密是指加密和解密都使用的是相同的密钥。\n\n![对称加密](对称加密.png)\n\n- 非对称加密\n\n\t- 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加\n密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来\n解密。\n\n![非对称加密](非对称加密.png)\n\n\t- 缺点\n\n\t\t- 第一个是非对称加密的效率太低。\n\t\t- 第二个是无法保证服务器发送给浏览器的数据安全。\n\n- 对称加密和非对称加密搭配使用\n\n\t- 在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。\n\n![对称混合非对称加密](对称混合非对称加密.png)\n\n- 添加数字证书\n\n![数字证书](数字证书.png)\n\n\t- ca证书中包含公司信息，公钥，等。\n\t- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n\t\t- 证书验证\n\n\t\t\t- 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n\n","slug":"浏览器安全","published":1,"updated":"2025-06-22T01:39:55.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc73233z000b0xtk07m2b25f","content":"<h1 id=\"浏览器安全\"><a href=\"#浏览器安全\" class=\"headerlink\" title=\"浏览器安全\"></a>浏览器安全</h1><h2 id=\"web网页安全\"><a href=\"#web网页安全\" class=\"headerlink\" title=\"web网页安全\"></a>web网页安全</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ul>\n<li><p>协议、域名和端口都相同</p>\n</li>\n<li><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</p>\n</li>\n<li><p>主要表现在 DOM、Web 数据和网络这三个层面</p>\n</li>\n<li><p>跨域共享数据</p>\n<ul>\n<li>cros</li>\n</ul>\n</li>\n<li><p>跨文档共享消息</p>\n<ul>\n<li>操作dom</li>\n<li>postMessage</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\"><a href=\"#CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\" class=\"headerlink\" title=\"CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\"></a>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</h3><h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><ul>\n<li><p>恶意代码注入攻击</p>\n<ul>\n<li><p>存储型攻击</p>\n<ul>\n<li>将恶意脚本发送给服务器，服务器存储在数据库中</li>\n</ul>\n</li>\n<li><p>反射型攻击</p>\n<ul>\n<li>不存储，将恶意脚本由服务器再返回给浏览器</li>\n</ul>\n</li>\n<li><p>基于 DOM 的 XSS 攻击</p>\n<ul>\n<li>在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>阻止策略</p>\n<ul>\n<li><p>原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n</li>\n<li><p>1、服务器对输入脚本进行过滤或转码</p>\n</li>\n<li><ol start=\"2\">\n<li>充分利用 CSP</li>\n</ol>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>使用 HttpOnly 属性</li>\n</ol>\n<ul>\n<li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li>\n<li>httpOnly由响应头设置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSRF-攻击，\"><a href=\"#CSRF-攻击，\" class=\"headerlink\" title=\"CSRF 攻击，\"></a>CSRF 攻击，</h3><ul>\n<li><p>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<ul>\n<li>1、自动发送get请求</li>\n<li>2、自动发送post请求</li>\n<li>3、引诱用户点击链接</li>\n<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</li>\n</ul>\n</li>\n<li><p>阻止攻击</p>\n<ul>\n<li><ol>\n<li>充分利用好 Cookie 的 SameSite 属性</li>\n</ol>\n<ul>\n<li><p>在set-cookie时设置</p>\n</li>\n<li><p>strict</p>\n<ul>\n<li>完全禁止第三方站点请求带上cookie</li>\n</ul>\n</li>\n<li><p>lax</p>\n<ul>\n<li><p>运行get请求</p>\n<ul>\n<li>post，img，iframe加载url时不允许的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>none</p>\n<ul>\n<li>完全开放请求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>验证请求的来源站点</li>\n</ol>\n<ul>\n<li><p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。</p>\n</li>\n<li><p>Origin 和 Referer 的一个主要区别。</p>\n<ul>\n<li>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，</li>\n<li>origin更优先</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>CSRF Token</li>\n</ol>\n<ul>\n<li>有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息</li>\n<li>第三方站点没有对应的csrf token</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浏览器系统安全\"><a href=\"#浏览器系统安全\" class=\"headerlink\" title=\"浏览器系统安全\"></a>浏览器系统安全</h2><h3 id=\"安全沙箱\"><a href=\"#安全沙箱\" class=\"headerlink\" title=\"安全沙箱\"></a>安全沙箱</h3><p><img src=\"%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1.png\" alt=\"安全沙箱\"></p>\n<ul>\n<li>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>\n<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>\n<li>安全沙箱最小的保护单位是进程。</li>\n</ul>\n<p><img src=\"%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png\" alt=\"渲染进程与浏览器内核\"> </p>\n<h3 id=\"无法阻止xss，csrf的攻击\"><a href=\"#无法阻止xss，csrf的攻击\" class=\"headerlink\" title=\"无法阻止xss，csrf的攻击\"></a>无法阻止xss，csrf的攻击</h3><h2 id=\"浏览器网络安全\"><a href=\"#浏览器网络安全\" class=\"headerlink\" title=\"浏览器网络安全\"></a>浏览器网络安全</h2><p><img src=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.png\" alt=\"浏览器安全\"></p>\n<h3 id=\"https加解密\"><a href=\"#https加解密\" class=\"headerlink\" title=\"https加解密\"></a>https加解密</h3><ul>\n<li><p>对称加密</p>\n<ul>\n<li>对称加密是指加密和解密都使用的是相同的密钥。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称加密\"></p>\n<ul>\n<li><p>非对称加密</p>\n<ul>\n<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加<br>密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来<br>解密。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"非对称加密\"></p>\n<pre><code>- 缺点\n\n    - 第一个是非对称加密的效率太低。\n    - 第二个是无法保证服务器发送给浏览器的数据安全。\n</code></pre>\n<ul>\n<li><p>对称加密和非对称加密搭配使用</p>\n<ul>\n<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称混合非对称加密\"></p>\n<ul>\n<li>添加数字证书</li>\n</ul>\n<p><img src=\"%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png\" alt=\"数字证书\"></p>\n<pre><code>- ca证书中包含公司信息，公钥，等。\n- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n    - 证书验证\n\n        - 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器安全\"><a href=\"#浏览器安全\" class=\"headerlink\" title=\"浏览器安全\"></a>浏览器安全</h1><h2 id=\"web网页安全\"><a href=\"#web网页安全\" class=\"headerlink\" title=\"web网页安全\"></a>web网页安全</h2><h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ul>\n<li><p>协议、域名和端口都相同</p>\n</li>\n<li><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</p>\n</li>\n<li><p>主要表现在 DOM、Web 数据和网络这三个层面</p>\n</li>\n<li><p>跨域共享数据</p>\n<ul>\n<li>cros</li>\n</ul>\n</li>\n<li><p>跨文档共享消息</p>\n<ul>\n<li>操作dom</li>\n<li>postMessage</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\"><a href=\"#CSP-的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联-JavaScript-代码。\" class=\"headerlink\" title=\"CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。\"></a>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</h3><h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><ul>\n<li><p>恶意代码注入攻击</p>\n<ul>\n<li><p>存储型攻击</p>\n<ul>\n<li>将恶意脚本发送给服务器，服务器存储在数据库中</li>\n</ul>\n</li>\n<li><p>反射型攻击</p>\n<ul>\n<li>不存储，将恶意脚本由服务器再返回给浏览器</li>\n</ul>\n</li>\n<li><p>基于 DOM 的 XSS 攻击</p>\n<ul>\n<li>在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>阻止策略</p>\n<ul>\n<li><p>原理：以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n</li>\n<li><p>1、服务器对输入脚本进行过滤或转码</p>\n</li>\n<li><ol start=\"2\">\n<li>充分利用 CSP</li>\n</ol>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>使用 HttpOnly 属性</li>\n</ol>\n<ul>\n<li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li>\n<li>httpOnly由响应头设置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSRF-攻击，\"><a href=\"#CSRF-攻击，\" class=\"headerlink\" title=\"CSRF 攻击，\"></a>CSRF 攻击，</h3><ul>\n<li><p>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<ul>\n<li>1、自动发送get请求</li>\n<li>2、自动发送post请求</li>\n<li>3、引诱用户点击链接</li>\n<li>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</li>\n</ul>\n</li>\n<li><p>阻止攻击</p>\n<ul>\n<li><ol>\n<li>充分利用好 Cookie 的 SameSite 属性</li>\n</ol>\n<ul>\n<li><p>在set-cookie时设置</p>\n</li>\n<li><p>strict</p>\n<ul>\n<li>完全禁止第三方站点请求带上cookie</li>\n</ul>\n</li>\n<li><p>lax</p>\n<ul>\n<li><p>运行get请求</p>\n<ul>\n<li>post，img，iframe加载url时不允许的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>none</p>\n<ul>\n<li>完全开放请求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>验证请求的来源站点</li>\n</ol>\n<ul>\n<li><p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。</p>\n</li>\n<li><p>Origin 和 Referer 的一个主要区别。</p>\n<ul>\n<li>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，</li>\n<li>origin更优先</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>CSRF Token</li>\n</ol>\n<ul>\n<li>有服务器想页面中注入csrf token，当在该页面发起请求时带上该信息</li>\n<li>第三方站点没有对应的csrf token</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"浏览器系统安全\"><a href=\"#浏览器系统安全\" class=\"headerlink\" title=\"浏览器系统安全\"></a>浏览器系统安全</h2><h3 id=\"安全沙箱\"><a href=\"#安全沙箱\" class=\"headerlink\" title=\"安全沙箱\"></a>安全沙箱</h3><p><img src=\"%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1.png\" alt=\"安全沙箱\"></p>\n<ul>\n<li>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</li>\n<li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</li>\n<li>安全沙箱最小的保护单位是进程。</li>\n</ul>\n<p><img src=\"%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png\" alt=\"渲染进程与浏览器内核\"> </p>\n<h3 id=\"无法阻止xss，csrf的攻击\"><a href=\"#无法阻止xss，csrf的攻击\" class=\"headerlink\" title=\"无法阻止xss，csrf的攻击\"></a>无法阻止xss，csrf的攻击</h3><h2 id=\"浏览器网络安全\"><a href=\"#浏览器网络安全\" class=\"headerlink\" title=\"浏览器网络安全\"></a>浏览器网络安全</h2><p><img src=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.png\" alt=\"浏览器安全\"></p>\n<h3 id=\"https加解密\"><a href=\"#https加解密\" class=\"headerlink\" title=\"https加解密\"></a>https加解密</h3><ul>\n<li><p>对称加密</p>\n<ul>\n<li>对称加密是指加密和解密都使用的是相同的密钥。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称加密\"></p>\n<ul>\n<li><p>非对称加密</p>\n<ul>\n<li>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加<br>密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来<br>解密。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"非对称加密\"></p>\n<pre><code>- 缺点\n\n    - 第一个是非对称加密的效率太低。\n    - 第二个是无法保证服务器发送给浏览器的数据安全。\n</code></pre>\n<ul>\n<li><p>对称加密和非对称加密搭配使用</p>\n<ul>\n<li>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png\" alt=\"对称混合非对称加密\"></p>\n<ul>\n<li>添加数字证书</li>\n</ul>\n<p><img src=\"%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png\" alt=\"数字证书\"></p>\n<pre><code>- ca证书中包含公司信息，公钥，等。\n- ca签名，hash函数对ca证书中的信息生成信息摘要，私钥加密生成ca签名\n\n    - 证书验证\n\n        - 浏览器获取ca证书后，用同样的hash函数生成信息摘要，用公钥解密签名生成信息摘要2，两两对比\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmc73233k00000xtk21au95ga","category_id":"cmc73233r00020xtk639w12ey","_id":"cmc732340000c0xtke6lygxrf"},{"post_id":"cmc73233w00050xtk51uw8hzs","category_id":"cmc73233y00080xtkc8se5wrf","_id":"cmc732341000i0xtk6qmu428u"},{"post_id":"cmc73233x00060xtkfban1nkj","category_id":"cmc732340000f0xtkdc913c9s","_id":"cmc732341000l0xtk6buu3jay"}],"PostTag":[{"post_id":"cmc73233k00000xtk21au95ga","tag_id":"cmc73233s00030xtkg6pg2yfc","_id":"cmc73233z00090xtkevm89hcd"},{"post_id":"cmc73233z000a0xtk9byshkh6","tag_id":"cmc73233y00070xtk8f3g8rrm","_id":"cmc732340000e0xtk02lg9u1n"},{"post_id":"cmc73233o00010xtk5u8h1xkj","tag_id":"cmc73233y00070xtk8f3g8rrm","_id":"cmc732341000g0xtk1rekcxrq"},{"post_id":"cmc73233w00050xtk51uw8hzs","tag_id":"cmc732340000d0xtk7ao1cg2w","_id":"cmc732341000j0xtkbj8c8cdu"},{"post_id":"cmc73233x00060xtkfban1nkj","tag_id":"cmc732341000h0xtkg4x3bpmz","_id":"cmc732342000m0xtkcixi5pd2"},{"post_id":"cmc73233z000b0xtk07m2b25f","tag_id":"cmc732341000k0xtk6jjn74on","_id":"cmc732342000n0xtkbdpm2fpx"}],"Tag":[{"name":"git javascript","_id":"cmc73233s00030xtkg6pg2yfc"},{"name":"持续更新（ing）","_id":"cmc73233y00070xtk8f3g8rrm"},{"name":"前端调接口下载","_id":"cmc732340000d0xtk7ao1cg2w"},{"name":"后端接口","_id":"cmc732341000h0xtkg4x3bpmz"},{"name":"安全","_id":"cmc732341000k0xtk6jjn74on"}]}}