---
title: 每天一个新问题（永远保持怀疑）
date: 2022-05-22 22:49:29
tag: 持续更新（ing）
categories: 前端
---

1、\<\> 、\<React.Fragment\>与\<div\>。前两者作为代码块插入的 form 表单中，form 表单无法获取其值，后者可以获得。

###### 答案：

```jsx
// form表单获取值是通过内部最近的控件的onchange（）事件和value值获取，<> 和 <React.Fragment>中是没有onchange（）和value事件的，所以form.item无法获取内部控件的值，（对children进行最近的控件的onchange的事件监听）。而div控件是有onchange事件的。（onchage事件是冒泡）
<Form.Item name="opterator" label="操作人：">
  <div
    onChange={(e) => {
      console.log("gerd => ", e);
    }}
  >
    <>
      <div
        onChange={(e) => {
          console.log(e);
          e.stopPropagation(); //阻止冒泡后，获取不到值
        }}
      >
        <input
          // style={{ width: '75%' }}
          placeholder="请输入操作人"
        />
      </div>
    </>
  </div>
</Form.Item>
```

2、antd 的 select 的默认属性值在 form 表单中不起作用，获取的是 undefined

###### 答案

> form 表单中控件的值默认初始化只能通过 form 的 initialValues 和 setFieldsValue 进行初始化，form.item 内部控件中的 defaultvalue 值只能展示，但是当获取时，通过 form 的 value 为 undefined。

3、this.setstate({data}),为了代码的简略性，常常使用 es6 的特性。易出现 state 值发生了变化，但是 render 函数并未触发。

###### 解答

> react 的 this.setstate 方法在对象引用是需要注意，当对象中属性发生变化时，对象引用即发生变化，当数组对象中成员添加时，引用未发生变化。建议通过 this.setstate({data: [...data]})的方式，将数组拆分赋值，实现引用的变化来触发 render 函数。

4、 当我们开发时，经常遇到 antd 中日期选择器的时间处理。

###### 解答

```js
// 通过monent函数转化，当然，monent需要引入函数库；import monent from 'monent';
startDate = moment(value.findDate[0].format('YYYY-MM-DD HH:mm:ss'));// 转化为开始日期
endDate = moment(value.findDate[1].format('YYYY-MM-DD HH:mm:ss'));// 转化为结束日期
// 此处的x为datepicker的value值哟。
日期=》时间戳： x.unix()
时间戳=》日期：moment( new Date(x * 1000 ))
```

5、当需要实现带状态跳转页面时，实现进出返回页面的页面信息一致。

###### 郭坤、史壮壮、徐雯等在林静第一次线下沟通时的讨论所得。

> 1）、redux
> 2）、将状态放在上级组件中存储
> 3）、放在 sessionstorage 或 localstorage 中存储

优缺点：redux 可避免状态外漏

| 序号 | 方法                                       | 优点                                  | 缺点                                                                                                                            |
| ---- | ------------------------------------------ | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 1    | redux                                      | 避免状态信息的泄漏                    | 每次不可以刷新页面进入，需通过路由跳转才能获取 props 中 redux 的值                                                              |
| 2    | 将状态放在上级组件中存储                   | 通过组件的 props 传值，获取值时机可靠 | 组件间耦合关系太深，开发繁琐                                                                                                    |
| 3    | 放在 sessionstorage 或 localstorage 中存储 | 存储值方便                            | 当页面跳转时，无法有效的删除 storage 和在 session 中泄露状态信息                                                                |
| 4    | 放在 url 中存储                            | 方便页面跳转获取参数                  | 当状态信息过多时，超出 url 长度。对于泄漏参数信息可以通过加密实现，最简单的 window.btoa()和 window.atob();window.atob()进行加密 |

```
6、<a href="#"></a>标签点击下，路由上会添加#，当有涉及到路由情况时要注意，比如umi的propmt控件，检测路由变化，当路由发生变化时才进入肉流程。反之不会。
    <Prompt
      when={this.state.submit} // sunmit为提交按钮状态 默认为false
      message={location => {
        if (this.state.submit) {
          Modal.confirm({
            icon: <ExclamationCircleOutlined />,
            content: '暂未提交您所做的更改，是否提交',
            okText: '继续加载',
            cancelText: '取消',
            onOk: () => {
              this.setState({ submit: false }, () => {
                this.props.history.push(`${location.pathname}`);
              });
            },
            onCancel: () => {},
          });
          return false; // 返回false时，阻塞路由跳转
        }
        return true; // 返回true时，路由跳转
      }}
```

7、永远不要修改 this.state 里的对象，要用 lodash 的 cloneDeep 实现对象隔离。chrome 也是人写的，不可避免的存在错误，不要相信没问题的工具。能相信的只有自己。！！！！

8、父组件向子组件传值，子组件的个别属性接收的是第一次组件的值。状态未刷新

###### 解答

        react的diff是根据组件的key值和value进行对比是否进行更换的，没有key值易出现传a但是接受到的还是b，状态没有刷新的情况。

9、定位问题，需要根据现有的情况进行定位。比如：当页面上路由展示不对时，应该尝试当 url 变化时，内容是否展示。是则是展示控件问题，通过查看版本锁，打包工具的不同对应的版本锁也不同。
10、验签问题，验签实质时获取申请的资源通过计算出想要的字段放在头文件中，每次调用接口都带上。

###### 坑

       当设计时间戳问题时，一般设置为前后三十秒。且为本机时间，这时候电脑时间要与网络同步，不然会验签不通过。

11、antd 的版本包问题：antdesign/proprolayout 依赖安装 ant 时，它默认安装最新的 antd 版本包。但是 antd 的版本包易出错，导致网站样式错误。

###### 解答

        通过指定安装antd版本，寻找无问题的antd版本可以安装无错误时间的antd版本，或者，依赖安装的prolayout中指定的antd版本。（到npm包仓库中找对应的版本包里的依赖项的版本）

13、为什么现在 peritter 在 vscode 中无法支持了？

###### 解答

        最新版的peritter的默认配置不是项目根目录的.preitterrc而是.editorconfig。需要在vscode的设置中将preitter的设置默认值.editorconfig的勾选项取消即可。

14、element-ui 的 input 的 type 为 textarea，文本框。在接收后端值进行赋值后，无法进行编辑。

###### 坑

    背景是，我有一个文本框，文本框内容可通过调用ai接口获取到最佳文本，然后将获取到的文本赋值给文本框。
    问题：在赋值前，文本框是可以编辑的，赋值后，文本框无法编辑。
    排查问题思路：
      1、看一下控制台是否有js报错。无报错。js逻辑没有问题
      2、看一下input组件的事件监听是否正常。onfucs。blurs事件均正常。组件的事件系统没有问题
      3、看一下element的dom节点是否正常。dom节点正常，textarea需要name或者id，否则会有提示信息。这个与问题原因无关
      4、看一下后端接口返回字段。因为，该页面为编辑页面涉及到一个初始化的流程。接口字段缺失导致该问题

###### 解答

    原因是，element-ui的input组件在初始化时，接口中没有返回相关字段，（不是字段为null，而是就没返回该字段）。使得页面中该组件绑定的值未被vue2的object。definepropertype监控到。渲染与数据层脱节。导致无法进行编辑。
    建议，前端在接到后端返回的接口数据源时，不要直接赋值。两个方案：
    1、一个一个字段的赋值，没有就赋值undefined
    2、通过object。asign（target，source）实现，后面的优先，这样至少可以放置接口返回字段缺失的问题。

15、推荐一个框架，https://www.renren.io/guide/security，覆盖大多数后台管理需求

16、为什么我明明安装了 nvm。重启后，再次打开终端输入 nvm 时候，被告知识别不到呢？配置文件也正确配置了，open ~/.bashrc

```

# tabtab source for electron-forge package
# uninstall by removing these lines or running `tabtab uninstall electron-forge`
[ -f /Users/ke/.nvm/versions/node/v20.11.1/lib/node_modules/electron-forge/node_modules/tabtab/.completions/electron-forge.bash ] && . /Users/ke/.nvm/versions/node/v20.11.1/lib/node_modules/electron-forge/node_modules/tabtab/.completions/electron-forge.bash
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

```

#### 答案

在终端中输入 source ～/.bashrc,激活配置即可。

#### 更简便的方法是在，终端启动时，就自动激活配置 open ~/.bash_profile

```

# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
__conda_setup="$('/opt/anaconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/anaconda3/etc/profile.d/conda.sh" ]; then
        . "/opt/anaconda3/etc/profile.d/conda.sh"
    else
        export PATH="/opt/anaconda3/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<

if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi


```
